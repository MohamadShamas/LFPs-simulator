
/* Generated by Interface Builder */

#import "defs.h"
#import "XYPlot.h"
#import <AppKit/AppKit.h>
#import <objc/Storage.h>
#import <math.h>		/* for MAXFLOAT, etc. */
#import <stdlib.h>
#import <strings.h>
#import <streams/streams.h>
#import <Foundation/NSUserDefaults.h>

/* The following routines are in auxil.m: */
extern void computeNiceLinInc(float *, float *, float *);
extern void computeNiceLogInc(float *, float *, float *);

#define MAXFLOAT 2e31

@implementation XYPlot

- init{
	[self initWithCanvas:nil];
	return self;
}

- setCanvas:view
{
	canvas = view;
	return self;
}

- initWithCanvas:view
{
	[super init];
	
	canvas = view;
	
	// Initialize variables here:
	nfilestotal = 0;
	ncurvestotal = 0;
	globaldatamin.x = MAXFLOAT;
	globaldatamin.y = MAXFLOAT;
	globaldatamax.x = -MAXFLOAT;
	globaldatamax.y = -MAXFLOAT;
	beepError = 0;
	backgroundcolor = [NSColor whiteColor];
	textcolor = [NSColor blackColor];
	//srandom(10);			/* initialize for color selection  */
	oldMin.x = 0.0;
	oldMin.y = 0.0;
	oldMax.x = 0.0;
	oldMax.y = 0.0;
	oldInc.x = 0.0;
	oldInc.y = 0.0;
	currentMin.x = 0.0;
	currentMin.y = 0.0;
	currentMax.x = 0.0;
	currentMax.y = 0.0;
	currentInc.x = 0.0;
	currentInc.y = 0.0;
	
	xAxisIsLog = NO;
	yAxisIsLog = NO;

	cycleLineStyle = YES;
	cycleSymbolStyle = YES;
	
	errorBars = NO_ERRORBARS;
	
	return self;
}

// Delete all data (free up the space that was malloc'ed)
- removeAllFiles:sender
{
  int n, j;
  datahunk *pdh;

  if (nfilestotal == 0) {
    return self;
  }

  for (n=nfilestotal-1; n>=0; n--) {
    pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
    for (j = 0; j < pdh->ncurves; j++) {
      free( (void *)*(pdh->y+j) );
    }
    free( (void *)(pdh->y) );
    if (pdh->has_eybars) {
      for (j = 0; j < pdh->ncurves; j++) {
        free( (void *)*(pdh->ey+j) );
      }
      free( (void *)(pdh->ey));
    }
    free( (void *)(pdh->x) );
    if (pdh->has_exbars) {
      free( (void *)(pdh->ex));
    }
    free( (void *)(pdh->filename) );
  }
  [datahunkArray empty];
  //[self adjustPanels:ncurvestotal :-1]; /* -1 is a special signal */
  nfilestotal = 0;

  //[columnSelectionHandler removeAll:self];

  //[errorBarHandler removeAll:self];

  //[canvas display];		/* clear the display */


  ncurvestotal = 0;

  // reset globaldatamin/max
  globaldatamin.x = MAXFLOAT;
  globaldatamin.y = MAXFLOAT;
  globaldatamax.x = -MAXFLOAT;
  globaldatamax.y = -MAXFLOAT;

  // clear xMin/Max/Inc and yMin/Max/Inc windows:
  //[xLimits setStringValue:"" at:0];
  //[xLimits setStringValue:"" at:1];
  //[xLimits setStringValue:"" at:2];
  //[yLimits setStringValue:"" at:0];
  //[yLimits setStringValue:"" at:1];
  //[yLimits setStringValue:"" at:2];

  //srandom(10);			/* initialize for color selection  */

  oldMin.x = 0.0;
  oldMin.y = 0.0;
  oldMax.x = 0.0;
  oldMax.y = 0.0;
  oldInc.x = 0.0;
  oldInc.y = 0.0;
  currentMin.x = 0.0;
  currentMin.y = 0.0;
  currentMax.x = 0.0;
  currentMax.y = 0.0;
  currentInc.x = 0.0;
  currentInc.y = 0.0;

  return self;
}

// Remove all existing files and open a new one
- removeAndOpen:sender
{
	if (NSRunAlertPanel(@"New", @"Remove all files, clear plot\nand open new file", @"OK", @"Cancel", nil) == NSAlertAlternateReturn) {
		return self;
	}

	[self removeAllFiles:self];
	[self open:self];

	return self;
}

// Use the OpenPanel object to get a filename
- open:sender
{

  NSArray *fileTypes = [NSArray arrayWithObject:NULL];

  char  fname[256];

  id openPanel = [NSOpenPanel openPanel]; 
	
  [openPanel setAllowsMultipleSelection:NO];

  [openPanel setAccessoryView:nil]; /* may have to clean out an accessory view */
  if (nfilestotal == 0) {
    if (errorBars) {
      [openPanel setTitle:@"Open (error bars)"];
    }
    else {
      [openPanel setTitle:@"Open"];	    /* make sure title is OK (cf. binary open) */
    }
  }
  else {
    if (errorBars) {
      [openPanel setTitle:@"Another (error bars)"]; /* 21 character limit here? */
    }
    else {
      [openPanel setTitle:@"Open Additional File"];
    }
  }

//#error StringConversion: Open panel types are now stored in an NSArray of NSStrings (used to use char**).  Change your variable declaration.
  if ([openPanel runModalForTypes:fileTypes])  {
    strncpy(fname, (char *)[[openPanel filename] cString], 256);
    // Check to see if we are trying to open a compressed file
    // We check for both ".Z" and ".gz"; we are assuming that the
    // decompression command zcat will handle both of these cases
    if (fname[strlen(fname)-1]=='Z' && fname[strlen(fname)-2]=='.') {
      //[self handleCompressedFile:fname];
    }
    else {
      [self openFile:fname :fname];
    }
  }
  return self;
}
/*
- handleCompressedFile:(char *)fname
{
  char  tempfname[256], command[512];

  // Uncompress the file into a temporary file:
  strcpy(tempfname, "/tmp/file000000.xyp");
  NXGetTempFilename(tempfname, 9);
  sprintf(command, "zcat %s > %s\n", fname, tempfname);
  // Possible danger ahead: no error checking; what if, e.g,  /tmp is full?
  system(command);
  // Now just go ahead and open the temporary file:
  [self openFile:tempfname :fname];
  // After returning from the openFile it is safe to unlink:
  unlink(tempfname);
  return self;
}
*/
- openFile:(char *)dataFile :(char *)realName
{
  NXStream *dataStream;
  
  if ((dataStream = NXMapFile(dataFile, NX_READONLY)) == NULL)  {
    NSRunAlertPanel(@"Open", @"Cannot open %s", @"OK", nil, nil, dataFile);
    return self;
  }

  if ([self readData:dataStream :realName] == 0)  {
    NSRunAlertPanel(@"Read", @"Couldn't read any data from %s", @"OK", nil, nil, dataFile);
    NXCloseMemory(dataStream, NX_FREEBUFFER);
    return self;
  }
  NXCloseMemory(dataStream, NX_FREEBUFFER);
  [self plotPrepAndDraw];
  return self;
}

/* return the x data for the nth file */
- (float *)xdata:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->x;
}

/* return the y data for the nth file */
- (float **)ydata:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->y;
}

/* return the y error data for the nth file */
- (float **)eydata:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->ey;
}

/* return the x error data for the nth file */
- (float *)exdata:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->ex;
}

/* return the number of x-points in the nth file */
- (int)nPoints:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->npoints;
}

/* return the number of curves in the nth file */
- (int)nCurves:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->ncurves;
}

/* return the name of the nth file */
- (char *)filename:(unsigned)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:n];
  return pdh->filename;
}

/* Does the nth file have error bars in y? */
- (BOOL) has_eybars:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->has_eybars;
}

/* Does the nth file have error bars in x? */
- (BOOL) has_exbars:(int)n
{
  datahunk *pdh;

  pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
  return pdh->has_exbars;
}

- (int)nCurvesTotal     { return ncurvestotal;}

- (int)nFiles           { return nfilestotal;}


- (BOOL) xAxisIsLog
{
  return xAxisIsLog;
}

- setXAxisToLinear
{
  xAxisIsLog = NO;
  return self;
}

- setXAxisToLog
{
  xAxisIsLog = YES;
  return self;
}

- (BOOL) yAxisIsLog
{
	return yAxisIsLog;
}

- setYAxisToLinear
{
  yAxisIsLog = NO;
  return self;
}

- setYAxisToLog
{
  yAxisIsLog = YES;
  return self;
}


- (int)providelinestyle:(int)aCurve
{
	/* First, if line is turned off, return that */
	if (cycleLineStyle == NO) {
	    return NOLINE;
	}
	else
    return aCurve % (N_LINE_STYLES - 1);
}

- (int)providesymbolstyle:(int)aCurve
{
	/* First, if symbols are turned off, return that */
	if (cycleSymbolStyle == NO) {
	    return NOSYMBOL;
	}
	else
    return aCurve % (N_SYMBOL_STYLES - 1);
}

/*
 * Changed floats to doubles in the following group.  With floats, when
 * the value was 250.4, the value returned by floatValueAt: was
 * 250.399994 (for example).  (This appears to be a problem with the
 * atof function on Unix 32-bit systems.)  This gave troubles in the
 * tic mark routine in PlotView.m.  
 */
- (double)provideXmin  {return xLimitsMin;}
- (double)provideXmax  {return xLimitsMax;}
- (double)provideXinc  {return xLimitsInc;}
- (double)provideYmin  {return yLimitsMin;}
- (double)provideYmax  {return yLimitsMax;}
- (double)provideYinc  {return yLimitsInc;}

- resetXmin:(double)aNum { xLimitsMin = aNum; return self; }
- resetXmax:(double)aNum { xLimitsMax = aNum; return self; }
- resetXinc:(double)aNum { xLimitsInc = aNum; return self; }
- resetYmin:(double)aNum { yLimitsMin = aNum; return self; }
- resetYmax:(double)aNum { yLimitsMax = aNum; return self; }
- resetYinc:(double)aNum { yLimitsInc = aNum; return self; }

- (float)provideGlobalXmin {return globaldatamin.x;}
- (float)provideGlobalYmin {return globaldatamin.y;}

- resetMinMax:sender
{
  int n;
  datahunk * pdh;

  // We have to go through all the data and recalculate min/max since
  // some data curves may have been "turned off" (by setting their linestyle
  // to none and symbolstyle to none).

  for (n=0; n<nfilestotal; n++) {
    pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
    [self findMinMax:pdh];
  }
  [self findGlobalMinMax];

  [self niceMinMaxInc];
    
  [self drawPlot:self];		/* redraw plot automatically */
  return self;
}


// We make the plotParam object responsible for checking parameters
// before the PlotView object is called.  Thus the PlotView object can
// assume the parameters are OK, and it doesn't have to do any checking.
// Things to check: xinc has the same sign as xmax-xmin (same for y);
// no negative data if log plot requested on x or y axis; there won't be
// too many tic marks requested.
- sanityCheck
{
  float xinc = [self provideXinc];
  float xmax = [self provideXmax], xmin = [self provideXmin];
  float yinc = [self provideYinc];
  float ymax = [self provideYmax], ymin = [self provideYmin];
  int   nticmarks;

  /* First check: no nonpositive data if logarithmic axis */
  /* Also check that increment is > 5 (need rint(log10(increment)) >=1 ) */
  if ( xAxisIsLog ) {
    if (globaldatamin.x <= 0.0 || xmin <= 0.0 || xmax <= 0.0) {
      xAxisIsLog = 0;	/* back to linear */
      NSBeep();			/* audible alert */
      beepError = 1;
    }
    if (xinc < 5.0) {
      [self resetXinc:(double)10.0];
      NSBeep();
      beepError = 12;
    }
  }
  if ( yAxisIsLog ) {
    if (globaldatamin.y <= 0.0 || ymin <= 0.0 || ymax <= 0.0) {
      yAxisIsLog = 0;	/* back to linear */
      NSBeep();			/* audible alert */
      beepError = 2;
    }
    if (yinc < 5.0) {
      [self resetYinc:(double)10.0];
      NSBeep();
      beepError = 12;
    }
  }
  /* Second check: xinc has same sign as xmax and xmin */
  if (xinc*(xmax-xmin) <= 0.0) { /* the bad case - avoid infinite loop */
    if (xinc < 0.0) {		/*     in PlotView:drawSelf           */
      xinc = -xinc;
      [self resetXinc:xinc];
      NSBeep();
      beepError = 3;
    }
    if (xmax <= xmin) {
      [self niceMinMaxInc];
      NSBeep();			/* alert */
      beepError = 4;
    }
  }
  /* And similarly for yinc */
  if (yinc*(ymax-ymin) <= 0.0) { /* the bad case - avoid infinite loop */
    if (yinc < 0.0) {
      yinc = -yinc;
      [self resetYinc:yinc];
      NSBeep();			/* alert */
      beepError = 5;
    }
    if (ymax <= ymin) {
      [self niceMinMaxInc];
      NSBeep();			/* alert */
      beepError = 6;
    }
  }
  /* Third check: no more than 100 (say) tic marks on either axis */
  if ( !xAxisIsLog ) {	/*  linear axis */
    nticmarks = (int) ((xmax - xmin) / xinc) ;
    if (nticmarks > 100) {
      computeNiceLinInc(&xmin, &xmax, &xinc);
      [self resetXmin:xmin];
      [self resetXmax:xmax];
      [self resetXinc:xinc];
      NSBeep();			/* alert */
      beepError = 7;
    }
  }
  if ( !yAxisIsLog ) {	/*  linear axis */
    nticmarks = (int) ((ymax - ymin) / yinc) ;
    if (nticmarks > 100) {
      computeNiceLinInc(&ymin, &ymax, &yinc);
      [self resetYmin:ymin];
      [self resetYmax:ymax];
      [self resetYinc:yinc];
      NSBeep();			/* alert */
      beepError = 8;
    }
  }

  return self;
}

- drawPlot:sender
{
  char c_xmin[20], c_xmax[20], c_ymin[20], c_ymax[20], c_xinc[20], c_yinc[20];
  float xmin, xmax, ymin, ymax, xinc, yinc;

  if (nfilestotal == 0) return self;

  [self sanityCheck];		/* disallow various bad parameters */

  /* maybe save min/max/inc */
  /* This really gets crufty: when we look at the TextField xMin and
   * get its float value via [xLimits floatValueAt:0], we get
   * a float which is the result of applying atof() to a string.  The
   * float which results may not be the same as the float that was originally
   * written into the TextField.  So we apply the process ourselves:
   * float --> string (via sprintf) --> float (via atof).  Ugly, but necessary
   * (otherwise, if you zoom, then hit the Plot button twice, then hit
   * the Previous View button, you might not get back to where you want).
   */
  sprintf(c_xmin,"%g",currentMin.x);
  sprintf(c_xmax,"%g",currentMax.x);
  sprintf(c_xinc,"%g",currentInc.x);
  sprintf(c_ymin,"%g",currentMin.y);
  sprintf(c_ymax,"%g",currentMax.y);
  sprintf(c_yinc,"%g",currentInc.y);
  xmin = (float)atof(c_xmin);
  xmax = (float)atof(c_xmax);
  xinc = (float)atof(c_xinc);
  ymin = (float)atof(c_ymin);
  ymax = (float)atof(c_ymax);
  yinc = (float)atof(c_yinc);
  if ( xLimitsMin != xmin
      || xLimitsMin != xmax
      || xLimitsInc != xinc
      || yLimitsMin != ymin
      || yLimitsMax != ymax
      || yLimitsInc != yinc ) {
    oldMin.x = currentMin.x;
    currentMin.x = xLimitsMin;
    oldMax.x = currentMax.x;
    currentMax.x = xLimitsMax;
    oldInc.x = currentInc.x;
    currentInc.x = xLimitsInc;
    oldMin.y = currentMin.y;
    currentMin.y = yLimitsMin;
    oldMax.y = currentMax.y;
    currentMax.y = yLimitsMax;
    oldInc.y = currentInc.y;
    currentInc.y = yLimitsInc;
  }

  [canvas display];

  return self;
}

// Allocate enough memory and read the data points
/*
 * This code makes the following assumptions:
 * 1. Any data on a line following the character "!" is to be discarded.
 * 2. We can determine the number of curves by looking at the first
 * line of data, which should be of the form
 *  x  y1  y2    ...    yn
 * (possibly separated by commas, with possible trailing comment).
 * 3. Other lines of the file may contain arbitrary text, but contain no
 * numerals or periods (these get interpreted as floating point numbers
 * when the file is scanned); also, anything after a "!" is discarded.
 *
 * It is not easy to make a completely general and bullet-proof scanning
 * routine.  This code is fairly robust and was easy to write.
 */
- (int) readData:(NXStream *)aDataStream :(char *)fname
{
  BOOL    inword = NO;
  char    c;
  int     j, size = ALLOCSIZE;
  int     tmpint = 0;		/* tmpint initialized to avoid compiler warning */
  int     oldncurves = ncurvestotal;
  datahunk *pdh = (void *)NULL;
  BOOL    noxdata = NO;
  float   tmpfloat = 0.0;	/* initialized to avoid compiler warning */
  
  [self preludeToReading:fname :&pdh];	/* take care of some housekeeping */
  
  NXSeek(aDataStream,0L,NX_FROMSTART);

  /* Figure out the number of curves in the file by reading characters  */
  /* until a newline is encountered; the number of curves is one less   */
  /* than the number of words found.                                    */
  /* We assume the input file is an ascii file; a compressed file will  */
  /* have been pumped through zcat and written to a temporary file.     */
  pdh->ncurves = -1;
top_of_file: ;
  while (1) {
    c = (char)NXGetc(aDataStream);
    if (c == (char)EOF) {
      break;			/* EOF, break out of while loop */
    }
    if (c == '\n') {
      if (pdh->ncurves == -1) {
	goto top_of_file;	// ugh, but there may be a blank line
      }
      else {
	break;			/* we have found some data, break from while loop */
      }
    }
    if (c == '!') {		/* comment signal: start discarding characters */
      while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ; /*  do nothing */
      if (pdh->ncurves == -1)	/* any data found yet? */
	goto top_of_file;		/* ugh */
      else
	break;
    }
    else if ((inword==NO) && !(c==' ' || c=='\t')) {
      pdh->ncurves++;
      inword = YES;
    }
    else if ((inword==YES) && (c==' ' || c=='\t')) {
      inword = NO;
    }
  }
  if (pdh->ncurves == -1) {	/* couldn't find "\n", give up (after cleanup) */
    //[plotButton setAltTitle:"Plotting"]; /* reset plot button */
    //[plotButton highlight:NO];
    //NXPing();			           /* force redraw */
    free( (void *)(pdh->filename) );
    nfilestotal--;
    return 0;
  }
  if (pdh->ncurves == 0) {	/* only one column, assume x data are integers */
    noxdata = YES;
    tmpfloat = 1.0;
    pdh->ncurves = 1;
    if (pdh->has_exbars || pdh->has_eybars) {
      NSRunAlertPanel(@"Read Data (with error bars)", [NSString stringWithCString:"Error bars expected, only one curve found\n"
		      "Unsetting error bar button and continuing"], @"OK", nil, nil);
      errorBars = NO_ERRORBARS;
      pdh->has_exbars = NO;
      pdh->has_eybars = NO;
    }
  }

  /*
   * We read more than one column; if there are error bars we must adjust ncurves.
   *    case            pdh->ncurves        true no. of curves
   *   y only            2n                    n
   *   x only            n (>=2)               n-1
   *   y and x          2n+1 (>=3)             n
   */
  if (pdh->has_eybars && !pdh->has_exbars) {
    if ( pdh->ncurves % 2  !=  0 ) {
      NSRunAlertPanel(@"Read Data (with error bars)", [NSString stringWithCString:"Strange number of curves found\n"
		      "Unsetting error bar button and continuing"], @"OK", nil, nil);
      errorBars = NO_ERRORBARS;
      pdh->has_eybars = NO;
    }
    else {
      pdh->ncurves = pdh->ncurves / 2;
    }
  }
  else if (pdh->has_exbars && !pdh->has_eybars) {
    if ( pdh->ncurves < 2 ) {
      NSRunAlertPanel(@"Read Data (with error bars)", [NSString stringWithCString:"Too few curves found\n"
		      "Unsetting error bar button and continuing"], @"OK", nil, nil);
      errorBars = NO_ERRORBARS;
      pdh->has_exbars = NO;
    }
    else {
      pdh->ncurves--;
    }
  }
  else if (pdh->has_exbars && pdh->has_eybars) {
    if ( pdh->ncurves < 3  ||  pdh->ncurves % 2 == 0 ) {
      NSRunAlertPanel(@"Read Data (with error bars)", [NSString stringWithCString:"Bad number of curves found\n"
		      "Unsetting error bar button and continuing"], @"OK", nil, nil);
      errorBars = NO_ERRORBARS;
      pdh->has_exbars = NO;
      pdh->has_eybars = NO;
    }
    else {
      pdh->ncurves = (pdh->ncurves - 1) / 2;
    }
  }

  /* Now read the data into memory */
  NXSeek(aDataStream, 0L, NX_FROMSTART);
    
  pdh->x = (float *)malloc( size * sizeof(float) );
  if (pdh->has_exbars) {
    pdh->ex = (float *)malloc( size * sizeof(float) );
  }
  pdh->y = (float **)malloc( pdh->ncurves * sizeof(float *) );
  for (j = 0; j < pdh->ncurves; j++) {
    *(pdh->y+j) = (float *)malloc( size * sizeof(float) );
  }
  if (pdh->has_eybars) {
    pdh->ey = (float **)malloc( pdh->ncurves * sizeof(float *) );
    for (j = 0; j < pdh->ncurves; j++) {
      *(pdh->ey+j) = (float *)malloc( size * sizeof(float) );
    }
  }
  pdh->npoints = 0;
  while(1) {
    if (noxdata) {
      *(pdh->x+pdh->npoints) = tmpfloat++;
    }
    else {
      if (pdh->has_exbars) {	/* x error bars, read two items*/
	while ( (tmpint=NXScanf(aDataStream, "%f", pdh->x+pdh->npoints)) == 0 ) {
	  if (c == '!') {
	    while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ; /* do nothing */
	    goto skipline;	/* ugh */
	  }
	}
	while ( (tmpint=NXScanf(aDataStream, "%f", pdh->ex+pdh->npoints)) == 0 ) {
	  if (c == '!') {
	    while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ; /* do nothing */
	    goto skipline;	/* ugh */
	  }
	}
      }
      else {			/* no x error bars, read one item */
	while ( (tmpint=NXScanf(aDataStream, "%f", pdh->x+pdh->npoints)) == 0 ) {
	  c = (char)NXGetc(aDataStream);	/* throw away extraneous characters */
	  if (c == '!') {
	    while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ; /* do nothing */
	    goto skipline;	/* ugh */
	  }
	}
      }
      if (tmpint == EOF) break;	/* break out of the while(1) loop */
    }

    if (pdh->has_eybars) {	/* y error bars, read two items */
      for (j = 0; j < 2 * pdh->ncurves; j++) {
	if (j%2 == 0) {		/* j is even, reading y value */
	  while( (tmpint=NXScanf(aDataStream, "%f", *(pdh->y+(j/2))+ pdh->npoints)) == 0 ) {
	    c = (char)NXGetc(aDataStream);	/* throw away the next character */
	    if (c == '!') {		/* comment signal; start discarding characters */
	      while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ; /* do nothing */
	      goto skipline;	/* ugh */
	    }
	  }
	}
	else {			/* j is odd, reading error */
	  while( (tmpint=NXScanf(aDataStream, "%f", *(pdh->ey+(j-1)/2)+ pdh->npoints)) == 0 ) {
	    c = (char)NXGetc(aDataStream);
	    if (c == '!') {
	      while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ;
	      goto skipline;
	    }
	  }
	}
      }
    }
    else {			/* no error bars, read one item */
      for (j = 0; j < pdh->ncurves; j++) {
/*
 * Try to allow extraneous characters here (if scanf returns 0, which means
 * it didn't find a number, just do a getc on the input stream to throw that
 * character away.  This will allow commas and alphabetic characters in the
 * middle of an input line (no digits or periods, though!).
 */
	while( (tmpint=NXScanf(aDataStream, "%f", *(pdh->y+j)+ pdh->npoints)) == 0 ) {
	  c = (char)NXGetc(aDataStream);	/* throw away the next character */
	  if (c == '!') {		/* comment signal; start discarding characters */
	    while ( (c=(char)NXGetc(aDataStream)) != '\n' ) ; /* do nothing */
	    goto skipline;	/* ugh */
	  }
	}
      }
    }
    if (tmpint == EOF) break;	/* could get this if noxdata==YES */
    pdh->npoints++;
    if (pdh->npoints == size) {		/* get more memory */
      size += ALLOCSIZE;
      pdh->x = (float *)realloc(pdh->x, size * sizeof(float));
      if (pdh->has_exbars) {
	pdh->ex = (float *) realloc(pdh->ex, size * sizeof(float));
      }
      for (j = 0; j < pdh->ncurves; j++) {
	*(pdh->y+j) = (float *)realloc( *(pdh->y+j), size * sizeof(float) );
      }
      if (pdh->has_eybars) {
	for (j = 0; j < pdh->ncurves; j++) {
	  *(pdh->ey+j) = (float *)realloc( *(pdh->ey+j), size * sizeof(float) );
	}
      }
    }
skipline: ;
  }

  [self postludeToReading:fname :oldncurves :pdh];

  ncurvestotal += pdh->ncurves;

  return pdh->npoints;
}

/* Might want to make sure INLINE_MATH is defined when math.h is included
 * (for guaranteed fast logarithms?)
 */
- checkLinLog:(datahunk *)pdh
{
  /* Check x and y axes -- do a heuristic test for log/lin.
   * The test employed comes from M. Merriam and xyplot.
   */
  double    scale, linsum, logsum;
  register  double tmp;
  int       i, j;

  /* First test x axis.  */
  if (pdh->datamax.x > 0.0  &&  pdh->datamin.x > 0.0
      && pdh->datamax.x != pdh->datamin.x) {
    scale = fabs( (double)pdh->datamax.x - (double)pdh->datamin.x );
    linsum = 0.0;
    for (j=1; j<pdh->npoints; j++) {
      tmp = ( (double)pdh->x[j]-(double)pdh->x[j-1] )/(double)scale;
      linsum += tmp*tmp;
    }
    scale = log10( (double)pdh->datamax.x/(double)pdh->datamin.x );
    /* what if datamax.x<datamin.x? */
    logsum = 0.0;
    for (i=1; i<pdh->npoints; i++) {
      tmp = log10( (double)pdh->x[i]/(double)pdh->x[i-1] ) / scale;
      logsum += tmp*tmp;
    }
    if (linsum < logsum) {
      pdh->xaxislin = YES;	/* linear axis */
    }
    else {
      pdh->xaxislin = NO;	/* logarithmic axis */
    }
  }
  else {
    pdh->xaxislin = YES;	/* linear */
  }
  /* Now test y axis */
  if (pdh->datamax.y > 0.0  &&  pdh->datamin.y > 0.0
      && pdh->datamax.y != pdh->datamin.y) {
    scale = fabs( (double)pdh->datamax.y - (double)pdh->datamin.y );
    linsum = 0.0;
    for (j=0; j<pdh->ncurves; j++) {
      for (i=1; i<pdh->npoints; i++) {
	tmp = ( (double)*(*(pdh->y+j)+i) - (double)*(*(pdh->y+j)+i-1) )
	  / scale;		/* avoid overflow */
	linsum += tmp*tmp;
      }
    }
    scale = log10((double)pdh->datamax.y/(double)pdh->datamin.y);
    logsum = 0.0;
    for (j=0; j<pdh->ncurves; j++) {
      for (i=1; i<pdh->npoints;i++) {
	tmp = log10( (double)*(*(pdh->y+j)+i)/(double)*(*(pdh->y+j)+i-1) ) / scale;
	logsum += tmp*tmp;
      }
    }
    if (linsum < logsum) {
      pdh->yaxislin = YES;	/* linear axis */
    }
    else {
      pdh->yaxislin = NO;	/* logarithmic axis */
    }
  }
  else {
    pdh->yaxislin = YES;	/* linear */
  }
  return self;
}

// This routine works as follows:
// If these is just one file, we set the x and y axes to linear or logarithmic
// depending on our heuristic.
// If there is more than one file, we don't change the axes unless there
// would be an illegal result (trying to plot a negative number on a
// logarithmic axis).
- checkGlobalLinLog
{
  datahunk *pdh;

  if (nfilestotal == 1) {
    pdh = (datahunk *)[datahunkArray elementAt:0];
    if ( pdh->xaxislin || !xAxisIsLog) 
      xAxisIsLog = NO; /* linear */
    else
      xAxisIsLog = YES; /* logarithmic */ 
    if ( pdh->yaxislin || !yAxisIsLog)
      yAxisIsLog = NO; /* linear */
    else
      yAxisIsLog = YES; /* logarithmic */
  }
  else {
    if ( xAxisIsLog && globaldatamin.x <= 0.0) {
      xAxisIsLog = NO;	/* back to linear */
      //NXBeep();			/* audible alert */
      beepError = 9;
    }
    if ( yAxisIsLog && globaldatamin.y <= 0.0) {
      yAxisIsLog = NO;	/* back to linear */
      //NXBeep();			/* audible alert */
      beepError = 10;
    }
  }
  return self;
}


// Go through a particular datahunk and find values for datamin.x,
// datamax.x, datamin.y, datamax.y
// We ignore any curves that are "turned off" (linestyle=NONE & symbolstyle=NONE);
// if all curves in the datahunk are turned off we ignore the x-data, too.
- findMinMax:(datahunk *)pdh
{
  int i, j;
  datahunk *qdh;
  int n, ncurve;
  BOOL ignore;

  pdh->datamin.x = MAXFLOAT;
  pdh->datamax.x = -MAXFLOAT;
  pdh->datamin.y = MAXFLOAT;
  pdh->datamax.y = -MAXFLOAT;

  // Find out which curves belong to datahunk pdh
  ncurve = 0;
  for (n=0; n<nfilestotal; n++) {
    qdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
    if (qdh == pdh)
      break;
    else
      ncurve += qdh->ncurves;
  }
  // Now we know to look at curves ncurve, ncurve+1,...,ncurve+pdh->ncurves-1
	ignore = YES;
	for (n = ncurve; n < ncurve + pdh->ncurves; n++) {
		if ([self providelinestyle:n] != NOLINE
			|| [self providesymbolstyle:n] != NOSYMBOL)
	    ignore = NO;
	}

  // Now it's possible we want to ignore all the curves.
	if (ignore) return self;

  // If we don't ignore all the curves then we must look at the x data.
  for (i = 0; i < pdh->npoints; i++)  {
    pdh->datamin.x = MIN(pdh->datamin.x, pdh->x[i]);
    pdh->datamax.x = MAX(pdh->datamax.x, pdh->x[i]);
  }
  for (j = 0; j < pdh->ncurves; j++) {
    if ([self providelinestyle:(ncurve+j)] != NOLINE
	|| [self providesymbolstyle:(ncurve+j)] != NOSYMBOL) {
      for (i = 0; i < pdh->npoints; i++) {
	pdh->datamin.y = MIN(pdh->datamin.y, *(*(pdh->y+j)+i));
	pdh->datamax.y = MAX(pdh->datamax.y, *(*(pdh->y+j)+i));
      }
    }
  }
  return self;
}

- findGlobalMinMax
{
  int n;
  datahunk *pdh;

  globaldatamin.x = MAXFLOAT;
  globaldatamin.y = MAXFLOAT;
  globaldatamax.x = -MAXFLOAT;
  globaldatamax.y = -MAXFLOAT;
  for (n=0; n<nfilestotal; n++) {
    pdh = (datahunk *)[datahunkArray elementAt:(unsigned)n];
    globaldatamin.x = MIN(globaldatamin.x, pdh->datamin.x);
    globaldatamax.x = MAX(globaldatamax.x, pdh->datamax.x);
    globaldatamin.y = MIN(globaldatamin.y, pdh->datamin.y);
    globaldatamax.y = MAX(globaldatamax.y, pdh->datamax.y);
  }
   
	return self;
}

// Get pleasing values for the min, max, and increments
- niceMinMaxInc
{
  float fmin, fmax, finc, oldFmax;

  fmin = globaldatamin.x;
  fmax = globaldatamax.x;
	oldFmax = fmax;
  
  if(fmin==fmax){fmin-=1;fmax+=1;}
  
  if (xAxisIsLog ) {
    computeNiceLogInc(&fmin, &fmax, &finc);
  }
  else {
    computeNiceLinInc(&fmin, &fmax, &finc);
  }
  [self resetXmin:fmin];
  //[self resetXmax:fmax];
  [self resetXmax:oldFmax];
  [self resetXinc:finc];

  fmin = globaldatamin.y;
  fmax = globaldatamax.y;

  if(fmin==fmax){fmin-=1;fmax+=1;}

  if (yAxisIsLog ) {
    computeNiceLogInc(&fmin, &fmax, &finc);
  }
  else {
    computeNiceLinInc(&fmin, &fmax, &finc);
  }
  [self resetYmin:fmin];
  [self resetYmax:fmax];
  [self resetYinc:finc];
  return self;
}


- postludeToReading:(char *)fname :(int)oldncurves :(datahunk *)pdh
{
  int   j;

  /* Adjust the lineMatrix, symbolMatrix, and legendForm */
  //[self adjustPanels:oldncurves :pdh->ncurves];

  //if ([columnPanel isVisible])
    //[columnSelectionHandler fixPanel:self];

  /*
   * Error bars don't get drawn unless the error bar matrix is correct.
   * Therefore we don't test on visibility here, rather we test on pdh itself.
   */
  //if (pdh->has_exbars || pdh->has_eybars)
    //[errorBarHandler updatePanel:self];

  //if ([fileRemovalPanel isVisible])
    //[self fixFileRemovalPanel:self];

  /* reset plot button */
  //[plotButton setAltTitle:"Plotting"];
  //[plotButton highlight:NO];

  [self findMinMax:pdh];
  /*
   * Don't bother to check lin/log unless this is the first file or
   * we already have at least one logarithmic axis:
   */
  if (nfilestotal==1 || xAxisIsLog || yAxisIsLog ) {
    [self checkLinLog:pdh];
  }
  else {
    pdh->xaxislin = YES;
    pdh->yaxislin = YES;
  }

  curvecolors = (NSColor **)realloc((void *)curvecolors,
                              (ncurvestotal + pdh->ncurves) * sizeof(NSColor *));

  //[[canvas window] setTitleAsFilename:fname];

  if (!colorOption) {
    for (j=0; j<pdh->ncurves; j++) {
      curvecolors[j + ncurvestotal] = [NSColor blackColor];
    }
  }
  else {
  [self makeCurvesColorful:pdh]; /* adjust all the curve colors */
  }

  return self;
}

- preludeToReading:(char *)fname :(datahunk **)pdh
{
  datahunk dh;

  /* set plot button title "Reading" */
  //[plotButton setAltTitle:"Reading"];
  //[plotButton highlight:YES];
  //NXPing();			/* force plotButton redraw */
  
  if (nfilestotal == 0) {
    datahunkArray = [Storage newCount:1
	  elementSize:sizeof(datahunk)
	  description:"{*{float *}{float *}{float **}{float **}iiffff{BOOL}{BOOL}{BOOL}{BOOL}}"];
    *pdh = (datahunk *)[datahunkArray elementAt:0];
    if (*pdh == NULL) {
      NSRunAlertPanel(@"readData", [NSString stringWithCString:"Weird error 0: NULL pointer in readData\n"
		      "I can't continue"], @"OK", nil, nil);
      exit(0);
    }
    nfilestotal = 1;
  }
  else {
    [datahunkArray addElement:(void *)&dh];
    *pdh = (datahunk *)[datahunkArray elementAt:(unsigned)nfilestotal];
    if (*pdh == NULL) {
      NSRunAlertPanel(@"readData", [NSString stringWithCString:"Weird error 1: NULL pointer in readData\n"
		      "I can't continue"], @"OK", nil, nil);
      exit(0);
    }
    nfilestotal++;
  }
  (*pdh)->filename = (char *)malloc(strlen(fname) + 1);
  strncpy((*pdh)->filename, fname, strlen(fname) + 1);

  (*pdh)->has_exbars = NO;
  (*pdh)->has_eybars = NO;
  if (errorBars==Y_ERRORBARS) {
    (*pdh)->has_eybars = YES;
  }
  else if (errorBars==X_ERRORBARS) {
    (*pdh)->has_exbars = YES;
  }
  else if (errorBars==XY_ERRORBARS) {
    (*pdh)->has_exbars = YES;
    (*pdh)->has_eybars = YES;
  }

  return self;
}

- plotPrepAndDraw
{
  /* Check for linear or log on x and y axes */
  [self checkGlobalLinLog];

  [self findGlobalMinMax];

  /* Only check and reset min/max if this is the first file */
  if (nfilestotal == 1) {
    [self niceMinMaxInc];
  }

  [self drawPlot:self];
	    
  return self;
}

    
- whyTheBeep:sender
{
  switch(beepError) {
  case 0:
    NSRunAlertPanel(@"The Beep Panel", [NSString stringWithCString:"Press this button if the program beeps\n"
       "and you want to know why"], @"OK", nil, nil);
    break;
  case 1:
    NSRunAlertPanel(@"The Beep Happened Because:", @"x-axis changed from log to linear", @"OK", nil, nil);
    break;
  case 2:
    NSRunAlertPanel(@"The Beep Happened Because:", @"y-axis changed from log to linear", @"OK", nil, nil);
    break;
  case 3:
    NSRunAlertPanel(@"The Beep Happened Because:", @"x-increment was negative\n (I changed it)", @"OK", nil, nil);
    break;
  case 4:
    NSRunAlertPanel(@"The Beep Happened Because:", @"xmax was less than xmin\n (I changed them)", @"OK", nil, nil);
    break;
  case 5:
    NSRunAlertPanel(@"The Beep Happened Because:", @"y-increment was negative\n (I changed it)", @"OK", nil, nil);
    break;
  case 6:
    NSRunAlertPanel(@"The Beep Happened Because:", @"ymax was less than ymin\n (I changed them)", @"OK", nil, nil);
    break;
  case 7:
    NSRunAlertPanel(@"The Beep Happened Because:", [NSString stringWithCString:"Too many tic marks would have been on the x-axis\n"
		    " (I changed the min, max, and/or increment)"], @"OK", nil, nil);
    break;
  case 8:
    NSRunAlertPanel(@"The Beep Happened Because:", [NSString stringWithCString:"Too many tic marks would have been on the y-axis\n"
		    " (I changed the min, max, and/or increment)"], @"OK", nil, nil);
    break;
  case 9:
    NSRunAlertPanel(@"The Beep Happened Because:", [NSString stringWithCString:"x-axis was logarithmic but some datum was negative\n"
		    " (I changed x-axis to linear)"], @"OK", nil, nil);
    break;
  case 10:
    NSRunAlertPanel(@"The Beep Happened Because:", [NSString stringWithCString:"y-axis was logarithmic but some datum was negative\n"
		    " (I changed y-axis to linear)"], @"OK", nil, nil);
    break;
  case 11:
    NSRunAlertPanel(@"The Beep Happened Because:", @"tried to set color of a non-existent curve", @"OK", nil, nil);
    break;
  case 12:
    NSRunAlertPanel(@"The Beep Happened Because:", [NSString stringWithCString:"an increment was too small for a log axis\n"
		    " (I reset it)"], @"OK", nil, nil);
    break;
  }
  return self;
}

- (NSColor *) provideBackgroundColor
{
    return backgroundcolor;
}

- (NSColor *) provideTextColor
{
	return textcolor;
}

- (NSColor *) provideCurveColor:(int)aCurve
{
    return curvecolors[aCurve];
}


- (void)setBackgroundColor:(NSColor *)aColor
{
  backgroundcolor = aColor;
}

- (void)setTextColor:(NSColor *)aColor
{
  textcolor = aColor;
}

- setCurveColor:(int)curvenum :(NSColor *)aColor
{
  if (curvenum >= ncurvestotal) {
    NSBeep();
    beepError = 11;
  }
  else {
    curvecolors[curvenum] = aColor;
  }
  return self;
}


// Update the global colorOption variable.  PlotDelegate sends us
// this message when the color option on the preferences panel is toggled.
// Adjust all colors.
- colorOn:(BOOL)onOff
{
  int j;
  
  if (onOff) {
    colorOption = YES;
    //backgroundcolor = NX_COLORBLACK;
    //textcolor = NX_COLORWHITE;
    [self makeCurvesColorful:NULL];
  }
  else {
    colorOption = NO;
    backgroundcolor = [NSColor whiteColor];
    textcolor = [NSColor blackColor];
    // Now we set all curvecolors to black
    for (j=0; j < ncurvestotal; j++) {
      curvecolors[j] = [NSColor blackColor];
    }
  }
  //[textColorWell setColor:textcolor];
  //[backgroundColorWell setColor:backgroundcolor];
  //[curveColorWell setColor:textcolor];

  return self;
}

/* change the column which is to be taken as the x data */
- swapColumns:(int)prev_col :(int)col forFileNumber:(int)i
{
  datahunk *pdh;
  float    *tmp;

  if (col < 0 || prev_col < 0)	/* be very cautious */
    return self;

  if (col==0 && prev_col==0)	/* must avoid this special case */
    return self;

  pdh    = (datahunk *)[datahunkArray elementAt:(unsigned)i];
  if (prev_col == 0) {		/* was first column, generic x-data */
//  tmp    = pdh->x;		/* why doesn't this order work? */
//  pdh->x = *(pdh->y + col-1);
//  *(pdh->y + col-1) = tmp;
    tmp    = *(pdh->y + col-1);
    *(pdh->y + col-1) = pdh->x;
    pdh->x = tmp;
  }
  else if (col == 0) {		/* revert back to generic x-data */
    tmp    = *(pdh->y + prev_col - 1);
    *(pdh->y + prev_col - 1) = pdh->x;
    pdh->x = tmp;
  }
  else {			/* swapping y's only */
//    tmp    = *(pdh->y + prev_col - 1);
//    *(pdh->y + prev_col - 1) = *(pdh->y + col - 1);
//    *(pdh->y + col - 1) = tmp;
    tmp    = *(pdh->y + col - 1);
    *(pdh->y + col - 1)      = *(pdh->y + prev_col - 1);
    *(pdh->y + prev_col - 1) = pdh->x;
    pdh->x = tmp;
  }

  [self findMinMax:pdh];	/* reset these values here */
  [self findGlobalMinMax];

  return self;
}


/*
 * This function is called by the PlotView object during zooming.
 */
- stackOldMinMax:(float)xmin :(float)xmax :(float)ymin :(float)ymax
{
  oldMin = currentMin;		/* structure assignment */
  oldMax = currentMax;
  oldInc = currentInc;		/* have to deal with the increments, too */
  currentMin.x = xmin;
  currentMax.x = xmax;
  currentMin.y = ymin;
  currentMax.y = ymax;
  currentInc.x = xLimitsInc;
  currentInc.y = yLimitsInc;

  return self;
}

/*
 * This method is invoked by the "Previous View" button on the
 * control panel.
 */
- previousView:sender
{
  NSPoint tmp;

  [self resetXmin:(double)oldMin.x];
  [self resetXmax:(double)oldMax.x];
  [self resetXinc:(double)oldInc.x];
  [self resetYmin:(double)oldMin.y];
  [self resetYmax:(double)oldMax.y];
  [self resetYinc:(double)oldInc.y];
  tmp        = oldMin;
  oldMin     = currentMin;
  currentMin = tmp;
  tmp        = oldMax;
  oldMax     = currentMax;
  currentMax = tmp;
  tmp        = oldInc;
  oldInc     = currentInc;
  currentInc = tmp;

  [canvas display];

  return self;
}

// Set the colors on the new curves.
// This might also be called to set _all_ the colors (if the color
// option on the preferences panel has been toggled).
- makeCurvesColorful:(datahunk *)pdh
{
  int   j;
  float hue = 0.0;
#define N_PREDEFINED_COLORS 9
  NSColor * predefined_colors[] = {[NSColor redColor], [NSColor greenColor], [NSColor blueColor],
			         [NSColor cyanColor], [NSColor yellowColor], [NSColor magentaColor],
			         [NSColor orangeColor], [NSColor purpleColor], [NSColor brownColor]};
  if (pdh) {
    for (j=0; j<pdh->ncurves; j++) {
      if (j + ncurvestotal < N_PREDEFINED_COLORS) {
	curvecolors[j + ncurvestotal] = predefined_colors[j + ncurvestotal];
      }
      else {
	//hue = 0.8 * ((float)random())/RAND_MAX ; /* 2^31 - 1 */
	curvecolors[j + ncurvestotal] = [NSColor colorWithCalibratedHue:hue saturation:1.0 brightness:1.0 alpha:1.0];
      }
      /* nupdate curve no. on color panel */
      //[curveNumber setIntValue:j+ncurvestotal+1];
      /* and update the color */
      //[curveColorWell setColor:curvecolors[j+ncurvestotal]];
    }
  }
  else {
    // Here we set the colors on _all_ the curves.
    for (j=0; j<ncurvestotal; j++) {
      if (j < N_PREDEFINED_COLORS) {
	curvecolors[j] = predefined_colors[j];
      }
      else {
	//hue = 0.8 * ((float)random())/RAND_MAX ; /* 2^31 - 1 */
	curvecolors[j] = [NSColor colorWithCalibratedHue:hue saturation:1.0 brightness:1.0 alpha:1.0];
      }
    }
  }	
  return self;
}

@end
