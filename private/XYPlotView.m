
/* Generated by Interface Builder */

#import "defs.h"
#import "XYPlotView.h"
#import "UserPath.h"
#import <AppKit/AppKit.h>
#import <objc/Storage.h>
#import <math.h>		/* for MAXFLOAT, etc. */
#import <strings.h>
#import <Foundation/NSUserDefaults.h>
#import "XYPlot.h"

#define MAX_UPATH	4096

/* The following routines are in auxil.m: */
extern void count_labels(int *, double *, double, double, double);
extern void autoformat(double, double, double, int *);
extern void handformat(float, char *, int *);

@implementation XYPlotView

+ (NSMenu *)defaultMenu
{
    NSMenu *menuPrincipal;

    menuPrincipal = [NSMenu alloc];
    [menuPrincipal initWithTitle:@"menuPrincipal"];
    [menuPrincipal addItemWithTitle:@"copy" action:@selector(copyTIFtoPasteBoard) keyEquivalent:@""];
    [menuPrincipal addItemWithTitle:@"save" action:@selector(saveAsTiff:) keyEquivalent:@""];
    [menuPrincipal addItemWithTitle:@"toggle expand mode" action:@selector(toggleExpandMode) keyEquivalent:@""];
    [menuPrincipal addItemWithTitle:@"Save parameters" action:@selector(saveParameters) keyEquivalent:@""];
    [menuPrincipal addItemWithTitle:@"Load parameters" action:@selector(loadParameters) keyEquivalent:@""];
    [menuPrincipal addItemWithTitle:@"toolbox" action:@selector(showToolboxPanel) keyEquivalent:@""];

    return menuPrincipal;
}

- (void)saveParameters
{
    id sauvePanel;
    FILE *fp;
    static char aPath[256];

    sauvePanel = [NSSavePanel savePanel];

    [sauvePanel setRequiredFileType:@"xyp"];

    [sauvePanel setTitle:@"Save XY plot parameters"];

    if ([sauvePanel runModalForDirectory:[NSString stringWithCString:aPath] file:@"amd.xyp"]){

        strcpy(aPath, [[sauvePanel filename] cString]);
        fp = fopen([[sauvePanel filename] cString], "wt");
        [self memorizeValues];
        fprintf(fp,"%g %g %g %g %g %g %g %g", xMinValueMemo,xIncValueMemo,xMaxValueMemo,yMinValueMemo,yIncValueMemo,yMaxValueMemo, lineWidthValueMemo, offsetValueMemo);
        fclose(fp);
    }
}

- (void)loadParameters
{
    id ouvrePanel;
    FILE *fp;
    static char aPath[256];

    ouvrePanel = [NSOpenPanel savePanel];

    [ouvrePanel setRequiredFileType:@"xyp"];

    [ouvrePanel setTitle:@"Open XY plot parameters"];

    if ([ouvrePanel runModalForDirectory:[NSString stringWithCString:aPath] file:NULL]){

        strcpy(aPath, [[ouvrePanel filename] cString]);

        fp = fopen([[ouvrePanel filename] cString], "rt");
        fscanf(fp,"%lf %lf %lf %lf %lf %lf %lf %lf", &xMinValueMemo,&xIncValueMemo,&xMaxValueMemo,&yMinValueMemo,&yIncValueMemo,&yMaxValueMemo, &lineWidthValueMemo, &offsetValueMemo);
        [self setToMemoValues];
        fclose(fp);
    }

}


- (void)memorizeValues
{
    xMinValueMemo = [[XYMatrix cellAtRow:0 column:0] doubleValue];
    xIncValueMemo = [[XYMatrix cellAtRow:1 column:0] doubleValue];
    xMaxValueMemo = [[XYMatrix cellAtRow:2 column:0] doubleValue];

    yMinValueMemo = [[XYMatrix cellAtRow:3 column:0] doubleValue];
    yIncValueMemo = [[XYMatrix cellAtRow:4 column:0] doubleValue];
    yMaxValueMemo = [[XYMatrix cellAtRow:5 column:0] doubleValue];

    lineWidthValueMemo = [[XYMatrix cellAtRow:6 column:0] doubleValue];
    offsetValueMemo = [[XYMatrix cellAtRow:7 column:0] doubleValue];
}

- (void)setToMemoValues
{
    [[XYMatrix cellAtRow:0 column:0] setDoubleValue:xMinValueMemo];
    [[XYMatrix cellAtRow:1 column:0] setDoubleValue:xIncValueMemo];
    [[XYMatrix cellAtRow:2 column:0] setDoubleValue:xMaxValueMemo];

    [[XYMatrix cellAtRow:3 column:0] setDoubleValue:yMinValueMemo];
    [[XYMatrix cellAtRow:4 column:0] setDoubleValue:yIncValueMemo];
    [[XYMatrix cellAtRow:5 column:0] setDoubleValue:yMaxValueMemo];

    [[XYMatrix cellAtRow:6 column:0] setDoubleValue:lineWidthValueMemo];
    [[XYMatrix cellAtRow:7 column:0] setDoubleValue:offsetValueMemo];

    [self redrawPlot:self];
}

- (id)xymatrix
{
    return XYMatrix;
}

- (void)showToolboxPanel
{
    [toolboxPanel makeKeyAndOrderFront:self];
}

- (void)toggleExpandMode
{
    [[switchesMatrix cellAtRow:6 column:0] setIntValue:![[switchesMatrix cellAtRow:6 column:0] intValue]];
    expandMode = [[switchesMatrix cellAtRow:6 column:0] intValue];
    [self redrawPlot:self];
}


- saveAsTiff:sender
{
    NSImage * anImage;
    NSData * tiffData;
    id sauvePanel;

    sauvePanel = [NSSavePanel savePanel];

    [sauvePanel setRequiredFileType:@"tif"];

    [sauvePanel setTitle:@"Save TIF"]; /* make sure title is OK */
    if ([sauvePanel runModal])  
        {
            anImage = [NSImage alloc];
            [anImage initWithData:[self dataWithEPSInsideRect:[self bounds]]];
            tiffData = [anImage TIFFRepresentation];
            [tiffData writeToFile:[sauvePanel filename] atomically:NO];
        }

    return self;
}

- (void)copyTIFtoPasteBoard
{
    id pb;
    NSImage * anImage;
    NSData * tiffData;

    pb = [NSPasteboard generalPasteboard];
    [pb declareTypes:[NSArray arrayWithObject:NSTIFFPboardType] owner:self];

    anImage = [NSImage alloc];
    [anImage initWithData:[self dataWithEPSInsideRect:[self bounds]]];
    tiffData = [anImage TIFFRepresentation];
    [pb setData:tiffData forType:NSTIFFPboardType];
}

- initWithFrame:(NSRect)frameRect
{
    printf("initWithFrame\n");

    [super initWithFrame:frameRect];

    colorState = NO;
    xLinLogState = NO;
    yLinLogState = NO;

    theFontManager = [NSFontManager new];

    legendFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE-3];
    legendTitleFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE-2];
    xTitleFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE];
    yTitleFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE];
    mainTitleFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE+2];
    ticLabelFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE-2];


    [self setBorder:YES];
    [self setGrid:YES];
    [self setAutoMaxMinState:YES];
    [self setAutoPaperState:YES];
    [self setPaperSwitchRow:4];   // Set the "paper Type" to auto on switch
    [self setLogoFlag:YES];
    
//#error ArchiverConversion: put the contents of your 'awake' method at the end of your 'initWithCoder:' method instead

    plotParam = [[XYPlot allocWithZone:[self zone]] initWithCanvas:self];

    if(!theFontManager) theFontManager = [NSFontManager new];

    [plotParam colorOn:colorState];

    [self setXLinLogState:xLinLogState];
    [self setYLinLogState:yLinLogState];
    [self setAutoPaperState:autoPaperState];

    lineThickness = 0.0;
    borderBoxThickness = 3.0;

    gridThickness = 0.0;
    axisThickness = 0.0;
    legend = NO;
    majorTicMarks = YES;
    minorTicMarks = NO;
    errorBarBaseWidth = 3.0;

    handFormatXaxis = NO;

    handFormatYaxis = NO;

    frameBox = YES;

    [[[self menu] itemWithTitle:@"copy"] setTarget:self];
    [[[self menu] itemWithTitle:@"save"] setTarget:self];

    [[[self menu] itemWithTitle:@"Save parameters"] setTarget:self];
    [[[self menu] itemWithTitle:@"Load parameters"] setTarget:self];

    [[[self menu] itemWithTitle:@"toggle expand mode"] setTarget:self];
    [[[self menu] itemWithTitle:@"toolbox"] setTarget:self];

    return self;
}

- (float *)xdata:(int)n	/* we use this in drawing the legend curves */
{
    xlegend[0] = (legendbox.origin.x + 5.33333)/ppxunit;
    /* We used to have 5.0 instead of 5.33333, but that can give erroneous-looking
    * (albeit correct) results when writing to the screen: the pixels that are
    * turned on when drawing a filled circle, for example, are much different
    * when the circle's center is precisely at a pixel than when the circle's center
    * is not precisely at a pixel.  The results are much better when the center
    * of the circle is at a half-pixel point, and so that's what we do.
    */
    xlegend[1] = xlegend[0] + 40.0/ppxunit;
    /* curve fragment in legend is 40 pixels in length */
    if (!drawingLegendLines) xlegend[0] = 0.5*(xlegend[0] + xlegend[1]);
    return xlegend;
}

- (float **)ydata:(int)n	/* we use this in drawing the legend curves */
{
    int ncurves = [plotParam nCurvesTotal];
    int j;
    float yloc, yhgt;

    if(!legendFont){
        legendFont = [NSFont fontWithName:[NSString stringWithCString:DEFAULTFONT] size:DEFAULTFONTSIZE];
    }

    yhgt = [legendFont pointSize];
    yloc = (legendbox.origin.y - 2.0)/ppyunit;

    ylegend = (float **)realloc((void *)ylegend, ncurves*sizeof(float *));
    for (j = 0; j < ncurves; j++) {
        *(ylegend+j) = (float *)NULL; /* this is necessary */
        *(ylegend+j) = (float *)realloc((void *)*(ylegend+j), 2*sizeof(float));
        /* check for no lines and no symbols */
        if ( ([plotParam providelinestyle:j] == NOLINE)  &&
             ([plotParam providesymbolstyle:j] == NOSYMBOL) ) continue;
        /* check for empty curveTitle */
        if ((drawingLegendLines || drawingLegendSymbols) && curveTitle[0]=='\0')
            continue;
        yloc = yloc + (yhgt+0.33333)/ppyunit;
        /* We used to have just yhgt (instead of yhgt+0.33333); see comments in preceding
            * routine for the reason to change it.
            */
    }

    for (j=0; j<ncurves; j++) {
        *(*(ylegend+j)+0) = yloc;
        *(*(ylegend+j)+1) = yloc;
        /* check for no lines and no symbols */
        if( ([plotParam providelinestyle:j] == NOLINE)  &&
            ( [plotParam providesymbolstyle:j] == NOSYMBOL) )continue;
        /* check for empty curveTitle */
        if ((drawingLegendLines || drawingLegendSymbols) && curveTitle[0]=='\0')
            continue;
        yloc -= yhgt/ppyunit;
    }
    return ylegend;
}

- (BOOL)has_ebars:(int)n
{
    return NO;
}

- (int)nPoints:(int)n
{
    if (drawingLegendLines)  return 2;
    else return 1;
}

- (int)nCurves:(int)n
{
    return [plotParam nCurvesTotal];
}

- (int)nFiles
{
    return 1;
}

- setX:(float*)tabX andY:(float **)tabY nbVoies:(int)nbV nbPoints:(int)nbP
{
    initialTabX = tabX;
    initialTabY = tabY;
    initialNbVoies = nbV;
    initialNbPoints = nbP;

    [self makeStreamAndPlot];

    return self;
}

- makeStreamAndPlot
{
    NXStream *dataStream;
    int i,j;
    float offset;

    if ((dataStream = NXOpenMemory(NULL, 0, NX_READWRITE)) == NULL)
      {
        NSRunAlertPanel(@"Write Data", @"Cannot open memory for stream", @"OK", nil, nil, NULL);
        return self;
      }

    offset = [[XYMatrix cellAtRow:7 column:0] floatValue];

    for(i=0;i<initialNbPoints;i++)
      {
        if (initialTabX != NULL) NXPrintf(dataStream, "%g ", initialTabX[i]);
        else NXPrintf(dataStream, "%d ", i);

        for(j=0; j<initialNbVoies; j++)
          {
            NXPrintf(dataStream, "%g ", initialTabY[j][i] + j*offset);
          }

        NXPrintf(dataStream, "\n");
      }

    colorState = [[switchesMatrix cellAtRow:3 column:0] intValue];
    styledLines = [[switchesMatrix cellAtRow:4 column:0] intValue];
    opaqueBackground = [[switchesMatrix cellAtRow:5 column:0] intValue];
    expandMode = [[switchesMatrix cellAtRow:6 column:0] intValue];

    lineThickness = [[XYMatrix cellAtRow:6 column:0] floatValue];
    [self setGridDotted:[[switchesMatrix cellAtRow:0 column:0] intValue]];
    axes = YES;

    [self plotFromStream:dataStream];

    NXCloseMemory(dataStream,NX_FREEBUFFER);

    [[XYMatrix cellAtRow:0 column:0] setDoubleValue:[self xMinValue]];
    [[XYMatrix cellAtRow:1 column:0] setDoubleValue:[self xIncValue]];
    [[XYMatrix cellAtRow:2 column:0] setDoubleValue:[self xMaxValue]];

    [[XYMatrix cellAtRow:3 column:0] setDoubleValue:[self yMinValue]];
    [[XYMatrix cellAtRow:4 column:0] setDoubleValue:[self yIncValue]];
    [[XYMatrix cellAtRow:5 column:0] setDoubleValue:[self yMaxValue]];

    return self;
}

- plotFromStream:(NXStream *)dataStream
{
    [plotParam removeAllFiles:self];
    [plotParam readData:dataStream :""];
    [plotParam plotPrepAndDraw];
    return self;
}


- setDrawColor:(float) color
{
    PSsetgray(color);
    return self;
}

- drawLines:sender :(BOOL)xaxislog :(BOOL)yaxislog
    /*
     * This is coded so that when drawLines is called with plotParam as argument,
     * it draws the data curves; when drawLines is called with self (plotView) as
     * argument, it draws the short line segments in the legend box.
     */
{
    int i, j, jrun, n;
    float *x;
    float **y;
    UserPath *userPath = newUserPath();
    int npoints, ncurves;
    int curveindex = 0;		/* cumulative index */
    int linestyle;
    float pattern0[] = {};	/* solid      */
    float pattern1[] = {4.0, 4.0}; /* dash       */
    float pattern2[] = {1.0, 3.0}; /* dot        */
    float pattern3[] = {7.0, 3.0, 3.0, 3.0}; /* chain dash */
    float pattern4[] = {7.0, 4.0, 1.0, 4.0}; /* chain dot  */

    for (n=0; n<[sender nFiles]; n++) { /* loop over all active files */
        //beginUserPath(userPath,NO);
        x  = [sender xdata:n];
        y  = [sender ydata:n];
        ncurves = [sender nCurves:n];
        npoints = [sender nPoints:n];
        PSsetlinewidth([[NSDPSContext currentContext] isDrawingToScreen]? lineThickness :
                       printColor==0? MAX(lineThickness, LINE_WIDTH_IF_PRINTING_BW) :
                       MAX(lineThickness, LINE_WIDTH_IF_PRINTING_COLOR));
        for (jrun=curveindex; jrun<curveindex+ncurves; jrun++) {
            linestyle = [plotParam providelinestyle:jrun];

            if (styledLines == 0) linestyle = SOLID;

            [[plotParam provideCurveColor:jrun] set];
            switch(linestyle) {
                case SOLID:
                    PSsetdash(pattern0, 0, 0.0);
                    break;
                case DASH:
                    PSsetdash(pattern1, 2, 0.0);
                    break;
                case DOT:
                    PSsetdash(pattern2, 2, 0.0);
                    break;
                case CHAINDASH:
                    PSsetdash(pattern3, 4, 0.0);
                    break;
                case CHAINDOT:
                    PSsetdash(pattern4, 4, 0.0);
                    break;
                case NOLINE:			/* no lines */
                    continue;
            }
            if (linestyle == NOLINE) continue; /* no lines, go to next curve */
            /* If we're drawing the legend and there is no title, don't
                * bother to draw the line:
                */
            if (drawingLegendLines && curveTitle[0]=='\0') continue;
            j = jrun - curveindex;	/* for indexing into the y array */
            beginUserPath(userPath,NO);
            if (!xaxislog && !yaxislog) {
                UPmoveto(userPath,x[0]*ppxunit, *(*(y + j)) * ppyunit );
                for (i=1; i<npoints; i++) {
                    if ( (i % MAX_UPATH) == 0 ) {
                        endUserPath(userPath, dps_ustroke);
                        sendUserPath(userPath);
                        beginUserPath(userPath,NO);
                        UPmoveto(userPath,x[i-1]*ppxunit, *(*(y+j)+i-1) * ppyunit);
                    }
                    UPlineto(userPath,x[i]*ppxunit, *(*(y+j)+i) * ppyunit);
                }
                endUserPath(userPath, dps_ustroke);
                sendUserPath(userPath);
            }
            else
                if (!xaxislog && yaxislog) {
                    PSmoveto(x[0]*ppxunit, (float)log10((double)*(*(y + j))) * ppyunit );
                    for (i=1; i<npoints; i++) {
                        if ( (i % MAX_UPATH) == 0 ) {
                            endUserPath(userPath, dps_ustroke);
                            sendUserPath(userPath);
                            beginUserPath(userPath,NO);
                            UPmoveto(userPath,x[i-1]*ppxunit,
                                     (float)log10((double)*(*(y+j)+i-1)) * ppyunit);
                        }
                        UPlineto(userPath,x[i]*ppxunit,
                                 (float)log10((double)*(*(y+j)+i)) * ppyunit);
                    }
                    endUserPath(userPath, dps_ustroke);
                    sendUserPath(userPath);
                }
            else
                if (xaxislog && !yaxislog) {
                    PSmoveto((float)log10((double)x[0])*ppxunit, *(*(y + j)) * ppyunit );
                    for (i=1; i<npoints; i++) {
                        if ( (i % MAX_UPATH) == 0 ) {
                            endUserPath(userPath, dps_ustroke);
                            sendUserPath(userPath);
                            beginUserPath(userPath,NO);
                            UPmoveto(userPath,(float)log10((double)x[i-1])*ppxunit,
                                     *(*(y+j)+i-1) * ppyunit);
                        }
                        UPlineto(userPath,(float)log10((double)x[i])*ppxunit,
                                 *(*(y+j)+i) * ppyunit);
                    }
                    endUserPath(userPath, dps_ustroke);
                    sendUserPath(userPath);
                }
            else
                if (xaxislog && yaxislog) {
                    UPmoveto(userPath,(float)log10((double)x[0])*ppxunit,
                             (float)log10((double)*(*(y + j))) * ppyunit );
                    for (i=1; i<npoints; i++) {
                        if ( (i % MAX_UPATH) == 0 ) {
                            endUserPath(userPath, dps_ustroke);
                            sendUserPath(userPath);
                            beginUserPath(userPath,NO);
                            UPmoveto(userPath,(float)log10((double)x[i-1])*ppxunit,
                                     (float)log10((double)*(*(y+j)+i-1)) * ppyunit);
                        }
                        UPlineto(userPath,(float)log10((double)x[i])*ppxunit,
                                 (float)log10((double)*(*(y+j)+i)) * ppyunit);
                    }
                    endUserPath(userPath, dps_ustroke);
                    sendUserPath(userPath);
                }
        }
        curveindex += ncurves;
    }
    PSsetdash(pattern0, 0, 0.0);	/* back to solid lines  */
    return self;
}


- (void)clear:(id)sender
{
    /*
     * Derek Lisoski (dlisoski@cco.caltech.edu) suggests not drawing the
     * opaque background rectangle when you print or save a file.  Then
     * when you read the saved plots into a separate drawing program you
     * can overlay multiple plots or get the plots arbitrarily close to
     * each other.  There may be some problems with background colors
     * when importing into various applications (Create or Draw, e.g.)
     */
    if ([[NSDPSContext currentContext] isDrawingToScreen] || opaqueBackground == 1) {
        NSRectFill([self bounds]);
        /* for color; had NXEraseRect, but that always fills with white    */
    }
}

/*
 * This routine assumes it is called with xmin != xmax and ymin != ymax.
 * Bad things may happen if this is not the case.
 * The input parameters are assumed to be in pixel coordinates.
 */
- drawTicMarks:(float)xmin :(float)xmax :(float)ymin :(float)ymax
{
    float pattern0[] = {};	/* solid      */
    float pattern2[] = {1.0, 3.0}; /* dot        */
    double xinc_unscaled = [plotParam provideXinc];
    double yinc_unscaled = [plotParam provideYinc];
    double xmin_unscaled = [plotParam provideXmin];
    double ymin_unscaled = [plotParam provideYmin];
    double xmax_unscaled = [plotParam provideXmax];
    double ymax_unscaled = [plotParam provideYmax];
    /* It is useful in some fairly extreme cases to have the increments
        * not in pixel coordinates (otherwise can get "bad" labels).
        */
    char ticlabel[32];
    id smallTicLabelFont;
    float x, y, ticloc_rat, xticloc, yticloc;
    BOOL xAxisIsLog = [plotParam xAxisIsLog];
    BOOL yAxisIsLog = [plotParam yAxisIsLog];
    int  ticLocation;		/* 0=axes, 1=2 sides, 2=4 sides */
    float  ticmarklen = -1.0;
    int    nmin, ninc=0, nmax, j, i;
    float  ticloc, xwid, labelHgt, smallLabelHgt;
    double first;
    int    nlabels;
    int    axformat[3];


    [[plotParam provideTextColor] set];

    ticLocation = 2;


    if(!ticLabelFont)ticLabelFont =
        [NSFont fontWithName:[NSString stringWithCString:DEFAULTFONT] size:DEFAULTFONTSIZE];

    labelHgt = [ticLabelFont pointSize];

    smallLabelHgt = (labelHgt >= 10.0? labelHgt - 2.0 : 8.0);
    smallTicLabelFont = [NSFont fontWithName:[ticLabelFont fontName] size:smallLabelHgt];

    /* get tic font initialized */
    [ticLabelFont set];

    PSnewpath();
  //PSsetlinewidth([ticMarkThicknessText floatValue]);
    PSsetlinewidth(ticMarkThickness);
    if (xAxisIsLog) {		/* x-axis is logarithmic */
        nmin = (int)floor((double)(xmin/ppxunit));
        nmax = (int)ceil((double)(xmax/ppxunit));
        //ninc = (int)rint(log10(xinc_unscaled));
        if (ninc == 0) ninc = 1;	/* avoid infinite loop */
        if (handFormatXaxis) {
            axformat[0] = xFormatLeft;
            axformat[1] = xFormatRight;
            axformat[2] = xFormatExponent;
        }
        for (j=nmin; j<=nmax; j+=ninc) {
            if ( (float)j * ppxunit >= xmin &&  (float)j * ppxunit <= xmax ) {
                if (gridState) {
                    PSsetlinewidth(gridThickness);
                    PSmoveto((float)j * ppxunit, ymin);
                    if (gridDotted)
                        PSsetdash(pattern2, 2, 0.0);
                    else
                        PSsetdash(pattern0, 0, 0.0);
                    PSrlineto(0.0, ABS(ymax-ymin));
                    PSstroke();
                    PSsetlinewidth(ticMarkThickness);
                }
                PSmoveto((float)j * ppxunit, ymin - ticmarklen*6.0); /* big tic mark */
                PSsetdash(pattern0, 0, 0.0);
                PSrlineto(0.0, ticmarklen*6.0);
                PSstroke();
                if (ticLocation == 2) {	/* tics on right and top */
                    PSmoveto((float)j * ppxunit, ymax); /* big tic mark */
                    PSsetdash(pattern0, 0, 0.0);
                    PSrlineto(0.0, ticmarklen*6.0);
                    PSstroke();
                }
                if (!handFormatXaxis) {
                    ticloc_rat = labelHgt/DEFAULTFONTSIZE;
                    PSmoveto((float)j * ppxunit - ticloc_rat*8.0,
                             ymin - MAX(24.0*ticloc_rat,
                                        24.0*ticloc_rat*(ticmarklen+10.0)/10.0));
                    PSshow("10");
                    [smallTicLabelFont set];
                    PSmoveto((float)j * ppxunit + ticloc_rat*4.0,
                             ymin - MAX(16.0*ticloc_rat,
                                        8.0*ticloc_rat*(2.0 + 0.3*ticmarklen)));
                    sprintf(ticlabel, "%-5d", j);
                    PSshow(ticlabel);
                    [ticLabelFont set];
                }
                else {
                    x = (float) pow((double)10.0, (double)j);
                    handformat(x, ticlabel, axformat);
                    xwid = [ticLabelFont widthOfString:[NSString stringWithCString:ticlabel]];
                    PSmoveto((float)j * ppxunit - xwid/2.0,
                             ymin - labelHgt - MAX(5.0, 5.0*ticmarklen));
                    PSshow(ticlabel);
                }
            }
            if (minorTicMarks) {
                for (i=2; i<=9; i++) {
                    ticloc = (float)j * ppxunit + ppxunit*(float)log10((double)i);
                    if ( ticloc>xmin && ticloc<xmax ) {
                        PSmoveto(ticloc, ymin - ticmarklen*3.0); /* small tic mark */
                        PSrlineto(0.0, ticmarklen*3.0);
                        PSstroke();
                        if (ticLocation == 2) { /* tics on right and top */
                            PSmoveto(ticloc, ymax); /* small tic mark */
                            PSrlineto(0.0, ticmarklen*3.0);
                            PSstroke();
                        }
                    }
                }
            }
        }
    }
    else {			/* x-axis is linear */
    yticloc = (ticLocation > 0 ? ymin : 2.0*ticmarklen) ;
    /* If inc is big, skip tic marks entirely */
    if (fabs(xinc_unscaled) < fabs(xmax_unscaled - xmin_unscaled)) {
        count_labels(&nlabels, &first, xmin_unscaled, xinc_unscaled, xmax_unscaled);
        if (handFormatXaxis) {
            axformat[0] = xFormatLeft;
            axformat[1] = xFormatRight;
            axformat[2] = xFormatExponent;
        }
        else {
            autoformat(xmin_unscaled, xinc_unscaled, xmax_unscaled, axformat);
            xFormatLeft  = axformat[0];
            xFormatRight = axformat[1];
            xFormatExponent = axformat[2];
        }
        /*
         * next loop starts at -1 because there may be room for minor tic
         * marks to the left of the first major tic mark (after a zoom, e.g.)
         */
        for (i = -1; i < nlabels; i++) {
            /* Special test here for what should be exact 0 (but isn't sometimes
            * due to floating-point arithmetic.
            */
            if (fabs(first/xinc_unscaled + (float)i) < 4.0e-7) { /* ugly */
                x = 0.0;
            }
            else {
                x = (first + (xinc_unscaled)*(float)i) * ppxunit;
            }
            if (x >= xmin) {	/* ensure major tic mark won't be off edge */
                if (gridState) {
                    PSsetlinewidth(gridThickness);
                    PSmoveto(x, ymin);
                    if (gridDotted)
                        PSsetdash(pattern2, 2, 0.0);
                    else
                        PSsetdash(pattern0, 0, 0.0);
                    PSrlineto(0.0, ABS(ymax-ymin));
                    PSstroke();
                    PSsetlinewidth(ticMarkThickness);
                }
                /* Nothing at 0 if we're putting tic marks on axes:  */
                if (ticLocation > 0 || x != 0.0) {
                    PSmoveto(x, yticloc - ticmarklen*4.0);
                    PSsetdash(pattern0, 0, 0.0);
                    PSrlineto(0.0, ticmarklen*4.0);
                    PSstroke();
                    if (ticLocation == 2) { /* tics on right and top */
                        PSmoveto(x, ymax);
                        PSsetdash(pattern0, 0, 0.0);
                        PSrlineto(0.0, ticmarklen*4.0);
                        PSstroke();
                    }
                    handformat(x/ppxunit, ticlabel, axformat);
                    xwid = [ticLabelFont widthOfString:[NSString stringWithCString:ticlabel]];
                    PSmoveto(x - xwid/2.0, yticloc - labelHgt - MAX(5.0, 5.0*ticmarklen));
                    PSshow(ticlabel);
                }
            }
    if (minorTicMarks) {
        if (ticLocation > 0) { /* tic marks on frame */
            for (j=1; j<=9; j++) {
                ticloc = x + ((xinc_unscaled/10.0)*(float)j)*ppxunit;
                if (ticloc>xmin && ticloc<xmax) {
                    PSmoveto(ticloc, yticloc - ticmarklen*2.0);
                    PSrlineto(0.0, ticmarklen*2.0);
                    PSstroke();
                    if (ticLocation == 2) {	/* tics on right and top */
                        PSmoveto(ticloc, ymax);
                        PSrlineto(0.0, ticmarklen*2.0);
                        PSstroke();
                    }
                }
            }
        }
    else {
        for (j=1; j<=9; j++) {
            ticloc = x + ((xinc_unscaled/10.0)*(float)j)*ppxunit;
            if (ticloc>xmin && ticloc<xmax) {
                PSmoveto(ticloc, -ticmarklen);
                PSrlineto(0.0, 2.0*ticmarklen);
                PSstroke();
            }
        }
	}
    }
      }
    }
  }
	if (yAxisIsLog) {		/* y-axis is logarithmic */
	nmin = (int)floor((double)(ymin/ppyunit));
	nmax = (int)ceil((double)(ymax/ppyunit));
	//ninc = (int)rint(log10(yinc_unscaled));
	if (ninc == 0) ninc = 1;	/* avoid infinite loop */
	if (handFormatYaxis) {
            axformat[0] = yFormatLeft;
            axformat[1] = yFormatRight;
            axformat[2] = yFormatExponent;
        }
    for (j=nmin; j<=nmax; j+=ninc) {
    if ( (float)j * ppyunit >= ymin &&  (float)j * ppyunit <= ymax ) {
        if (gridState) {
            PSsetlinewidth(gridThickness);
            PSmoveto(xmin, (float)j * ppyunit);
            if (gridDotted)
                PSsetdash(pattern2, 2, 0.0);
            else
                PSsetdash(pattern0, 0, 0.0);
            PSrlineto(ABS(xmax-xmin), 0.0);
            PSstroke();
            PSsetlinewidth(ticMarkThickness);
        }
        PSmoveto(xmin - ticmarklen*6.0, (float)j * ppyunit); /* big tic mark */
        PSsetdash(pattern0, 0, 0.0);
        PSrlineto(ticmarklen*6.0, 0.0);
        PSstroke();
        if (ticLocation == 2) {	/* tics on right and top */
            PSmoveto(xmax, (float)j * ppyunit); /* big tic mark */
            PSsetdash(pattern0, 0, 0.0);
            PSrlineto(ticmarklen*6.0, 0.0);
            PSstroke();
        }
        if (!handFormatYaxis) {
            ticloc_rat = labelHgt/DEFAULTFONTSIZE;
            PSmoveto(xmin - MAX(40.0*ticloc_rat,
                                40.0*ticloc_rat*(ticmarklen+10.0)/10.0),
                     (float)j * ppyunit - ticloc_rat*7.0);
            PSshow("10");
            [smallTicLabelFont set];
            PSmoveto(xmin - MAX(24.0*ticloc_rat,
                                4.0*ticloc_rat*(ticmarklen + 6.0)),
                     (float)j * ppyunit - ticloc_rat*1.0);
            sprintf(ticlabel, "%-5d", j);
            PSshow(ticlabel);
            [ticLabelFont set];
        }
        else {
            y = (float) pow((double)10.0, (double)j);
            handformat(y, ticlabel, axformat);
            xwid = [ticLabelFont widthOfString:[NSString stringWithCString:ticlabel]];
            PSmoveto(xmin - xwid - MAX(10.0, 5.0*ticmarklen),
                     (float)j * ppyunit + 2.0 - labelHgt/2.0);
            PSshow(ticlabel);
        }
    }
    if (minorTicMarks) {
    for (i=2; i<=9; i++) {
        ticloc = (float)j * ppyunit + ppyunit*(float)log10((double)i);
        if (ticloc>ymin && ticloc<ymax) {
            PSmoveto(xmin - ticmarklen*3.0, ticloc); /* small tic mark */
            PSrlineto(ticmarklen*3.0, 0.0);
            PSstroke();
            if (ticLocation == 2) { /* tics on right and top */
                PSmoveto(xmax, ticloc); /* small tic mark */
                PSrlineto(ticmarklen*3.0, 0.0);
                PSstroke();
            }
        }
    }
}
}
}
else {			/* y-axis is linear */
xticloc = (ticLocation > 0 ? xmin : 2.0*ticmarklen) ;
/* If inc is big, skip tic marks entirely */
if (fabs(yinc_unscaled) < fabs(ymax_unscaled - ymin_unscaled)) {
    count_labels(&nlabels, &first, ymin_unscaled, yinc_unscaled, ymax_unscaled);
    if (handFormatYaxis) {
        axformat[0] = yFormatLeft;
        axformat[1] = yFormatRight;
        axformat[2] = yFormatExponent;
    }
    else {
        autoformat(ymin_unscaled, yinc_unscaled, ymax_unscaled, axformat);
        yFormatLeft = axformat[0];
        yFormatRight = axformat[1];
        yFormatExponent = axformat[2];
    }
    /*
     * next loop starts at -1 because there may be room for minor tic
     * marks to the left of the first major tic mark (after a zoom, e.g.)
     */
    for (i = -1; i < nlabels; i++) {
        /* Special test here for what should be exact 0 (but isn't sometimes
        * due to floating-point arithmetic.
        */
        if (fabs(first/yinc_unscaled + (float)i) < 4.0e-7) { /* ugly */
            y = 0.0;
        }
        else {
            y = (first + (yinc_unscaled)*(float)i) * ppyunit;
        }
        if (y >= ymin) {	/* ensure major tic mark won't be off edge */
            if (gridState) {
                PSsetlinewidth(gridThickness);
                PSmoveto(xmin, y);
                if (gridDotted)
                    PSsetdash(pattern2, 2, 0.0);
                else
                    PSsetdash(pattern0, 0, 0.0);
                PSrlineto(ABS(xmax-xmin), 0.0);
                PSstroke();
                PSsetlinewidth(ticMarkThickness);
            }
            /* Nothing at 0 if we're putting tic marks on axes:  */
            if (ticLocation > 0 || y != 0.0) {
                PSmoveto(xticloc - ticmarklen*4.0, y);
                PSsetdash(pattern0, 0, 0.0);
                PSrlineto(ticmarklen*4.0, 0.0);
                PSstroke();
                if (ticLocation == 2) { /* tics on right and top */
                    PSmoveto(xmax, y);
                    PSsetdash(pattern0, 0, 0.0);
                    PSrlineto(ticmarklen*4.0, 0.0);
                    PSstroke();
                }
                handformat(y/ppyunit, ticlabel, axformat);
                xwid = [ticLabelFont widthOfString:[NSString stringWithCString:ticlabel]];
                PSmoveto(xticloc - xwid - MAX(10.0, 5.0*ticmarklen),
                         y + 2.0 - labelHgt/2.0);
                PSshow(ticlabel);
            }
        }
if (minorTicMarks) {
    if (ticLocation > 0) { /* tics on frame */
        for (j=1; j<=9; j++) {
            ticloc = y + ((yinc_unscaled/10.0)*(float)j)*ppyunit;
            if (ticloc>ymin && ticloc<ymax) {
                PSmoveto(xticloc - ticmarklen*2.0, ticloc);
                PSrlineto(ticmarklen*2.0, 0.0);
                PSstroke();
                if (ticLocation == 2) {	/* tics on right and top */
                    PSmoveto(xmax, ticloc);
                    PSrlineto(ticmarklen*2.0, 0.0);
                    PSstroke();
                }
            }
        }
    }
else {
        for (j=1; j<=9; j++) {
            ticloc = y + ((yinc_unscaled/10.0)*(float)j)*ppyunit;
            if (ticloc>ymin && ticloc<ymax) {
                PSmoveto(-ticmarklen, ticloc);
                PSrlineto(2.0*ticmarklen, 0.0);
                PSstroke();
            }
        }
}
}
      }
    }
  }
return self;
}

- (void)drawRect:(NSRect)rects
{
    BOOL xAxisIsLog = [plotParam xAxisIsLog];
    BOOL yAxisIsLog = [plotParam yAxisIsLog];

    float  xmin = (float)[plotParam provideXmin];
    float  xmax = (float)[plotParam provideXmax];
    float  ymin = (float)[plotParam provideYmin];
    float  ymax = (float)[plotParam provideYmax];

    [[plotParam provideBackgroundColor] set];
    [self clear:self];

    [[plotParam provideTextColor] set];

    //PSsetgray(NSBlack);

    if ([plotParam nFiles] == 0) return; /* no data */

    if (xmin==xmax || ymin==ymax) return; /* avoid division by zero */

    PSgsave();

    PSsetmiterlimit(1);		// suggested by Carrick Talmadge
                                // (clt@eotvos.physics.purdue.edu)

    if (expandMode)
        PStranslate(XOFFSET_EXPAND, YOFFSET);
    else
        PStranslate(1.1 * XOFFSET, YOFFSET);

    if (xAxisIsLog) {	/* x-axis is logarithmic */
        ppxunit = 0.9*([self bounds].size.width-XOFFSET)/(float)log10((double)(xmax/xmin));
        xmin = (float)log10((double)xmin) * ppxunit;
        xmax = (float)log10((double)xmax) * ppxunit;
    }
    else {			/* x-axis is linear */
    if (expandMode)
    ppxunit = 0.9999*([self bounds].size.width-XOFFSET_EXPAND)/(xmax-xmin); // FW Aout 2001
    else
    ppxunit =  0.95*([self bounds].size.width-XOFFSET)/(xmax-xmin); // FW Aout 2001
    xmin = xmin*ppxunit;	/* drawing is all in pixel coordinates */
    xmax = xmax*ppxunit;
    }
    if (yAxisIsLog) {	/* y-axis is logarithmic */
    ppyunit = 0.9*([self bounds].size.height-YOFFSET*1.5)/(float)log10((double)(ymax/ymin));
    ymin = (float)log10((double)ymin) * ppyunit;
    ymax = (float)log10((double)ymax) * ppyunit;
    }
    else {			/* y-axis is linear */
    if (expandMode)
    ppyunit = 0.9999*([self bounds].size.height-YOFFSET*1.00)/(ymax-ymin); //FW Aout 2001
    else
    ppyunit = 0.96*([self bounds].size.height-YOFFSET*1.00)/(ymax-ymin); //FW Aout 2001
    ymin = ymin*ppyunit;
    ymax = ymax*ppyunit;
    }
    PStranslate(-xmin, -ymin);
  // inner "frame" box
    if (frameBox) {
    PSsetlinewidth(frameBoxThickness);
    PSnewpath();
    PSmoveto(xmin, ymin);
    PSlineto(xmax, ymin);
    PSlineto(xmax, ymax);
    PSlineto(xmin, ymax);
    PSclosepath();
    PSstroke();
    /* reset line width */
    PSsetlinewidth([[NSDPSContext currentContext] isDrawingToScreen]? 0.0 :
                   printColor? LINE_WIDTH_IF_PRINTING_COLOR :
                   LINE_WIDTH_IF_PRINTING_BW);
    }

    if (axes) {
    PSnewpath();
    PSsetlinewidth(axisThickness);
    PSmoveto(0.0, ymin);
    PSlineto(0.0, ymax);
    PSstroke();
    PSmoveto(xmin, 0.0);
    PSlineto(xmax, 0.0);
    PSstroke();
    }

    if (majorTicMarks) [self drawTicMarks:xmin :xmax :ymin :ymax]; /* do this before clipping */

    /* MIN and MAX below in case xmin > xmax  and/or  ymin > ymax. */
    PSrectclip(MIN(xmin,xmax), MIN(ymin,ymax), ABS(xmax-xmin), ABS(ymax-ymin));

    [self drawLines:plotParam :xAxisIsLog :yAxisIsLog];

    PSgrestore();
/*
    if (legend) {
        [self startLegend];
        [self drawLegend:self];
    }
*/
}

- saveEPS:sender
{
    NSData *epsData;

    id sauvePanel;

    sauvePanel = [NSSavePanel savePanel];

    [sauvePanel setRequiredFileType:@"eps"];

    [sauvePanel setTitle:@"Save EPS"]; /* make sure title is OK */
        if ([sauvePanel runModal])  
	{
            epsData = [self dataWithEPSInsideRect:[self bounds]];
            [epsData writeToFile:[sauvePanel filename] atomically:NO];
        }

        return self;
}

// For testing -- open data file via right mouse click...
/*
- (void)rightMouseDown:(NSEvent *)theEvent
{
    [self copyTIFtoPasteBoard];
    return;
}
*/
- setGrid:(int)grid_state{gridState=grid_state; return self;}
- setBorder:(int)border_state{ borderBox=border_state; return self;}
- setColorState:(int)color_state{colorState=color_state;return self;}
-(int)gridState{return gridState; }
-(int)borderState{ return borderBox;}
-(int)colorState{ return colorState;}

-setAutoMaxMinState:(int)state{autoMaxMinState=state; return self;}
-(int)autoMaxMinState{return autoMaxMinState;}

-setAutoPaperState:(int)state{
    autoPaperState=state;
        //[plotParam setXAxisToLog];
        //[plotParam setYAxisToLog];
    return self;
}
-(int)autoPaperState{return autoPaperState;}
-setXLinLogState:(int)state
{
    xLinLogState=state;
    if(state==NO)[plotParam setXAxisToLinear];
    else [plotParam setXAxisToLog];
    return self;
}
-(int)xLinLogState{return xLinLogState;}
-setYLinLogState:(int)state
{
    yLinLogState=state;
    if(state==NO)[plotParam setYAxisToLinear];
    else [plotParam setYAxisToLog];
    return self;
}
-(int)yLinLogState{return yLinLogState;}
-setPaperSwitchRow:(int)state{paperSwitchRow=state; return self;}
-(int)paperSwitchRow{return paperSwitchRow;}
-setLogoFlag:(int)state{logoFlag=state; return self;}
-(int)logoFlag{return logoFlag;}

- (void)setXIncValue:(float)passedValue{
    xIncValue = passedValue;
    [plotParam resetXinc:(double)passedValue];
}
- (void)setXMinValue:(float)passedValue{
    xMinValue = passedValue;
    [plotParam resetXmin:(double)passedValue];
}

- (void)setXMaxValue:(float)passedValue{
    xMaxValue = passedValue;
    [plotParam resetXmax:(double)passedValue];
}

- (void)setYIncValue:(float)passedValue{
    yIncValue = passedValue;
    [plotParam resetYinc:(double)passedValue];
}
- (void)setYMinValue:(float)passedValue{
    yMinValue = passedValue;
    [plotParam resetYmin:(double)passedValue];
}

- (void)setYMaxValue:(float)passedValue{
    yMaxValue = passedValue;
    [plotParam resetYmax:(double)passedValue];
}


-(float)xIncValue{return [plotParam provideXinc];}
-(float)xMinValue{return [plotParam provideXmin];}
-(float)xMaxValue{return [plotParam provideXmax];}
-(float)yIncValue{return [plotParam provideYinc];}
-(float)yMinValue{return [plotParam provideYmin];}
-(float)yMaxValue{return [plotParam provideYmax];}

- (void)setFrameSize:(NSSize)_newSize
// Allow resizing
{

    [super setFrameSize:_newSize];
    [self repositionTitles];
}

- (void)repositionTitles
{
    float	width,height;

    legendbox.origin.x = [self bounds].size.width - 50.0; /* get the legendbox initialized here */
    legendbox.origin.y = [self bounds].size.height - 50.0;

    if(xAxisTitle){
        width = [xTitleFont widthOfString:[NSString stringWithCString:xAxisTitle]];
        height = [xTitleFont pointSize];

        xtitlebox.origin.x = XOFFSET/4.0
            + ([self bounds].size.width - width) /2.0;
        xtitlebox.origin.y = [self bounds].origin.y + YOFFSET/4.0;
        xtitlebox.size.width  = width;
        xtitlebox.size.height = height;
    }

    if(yAxisTitle){
        width = [yTitleFont widthOfString:[NSString stringWithCString:yAxisTitle]];
        height = [yTitleFont pointSize];

        ytitlebox.origin.x = ([self bounds].origin.x + height/2) + XOFFSET/4.0;
        ytitlebox.origin.y = YOFFSET/4.0
            + ([self bounds].size.height - width) /2.0;
        ytitlebox.size.width  = width;
        ytitlebox.size.height = height;
    }

    if(mainTitle){
        width = [mainTitleFont widthOfString:[NSString stringWithCString:mainTitle]];
        height = [mainTitleFont pointSize];

        maintitlebox.origin.x = ([self bounds].size.width - width)/2.0;
        maintitlebox.origin.y = ([self bounds].size.height- height/2) - YOFFSET/4.0;
        maintitlebox.size.width  = width;
        maintitlebox.size.height = height;
    }

}

- mainTitleFont   { return mainTitleFont;}
- xTitleFont      { return xTitleFont;}
- yTitleFont      { return yTitleFont;}
- legendTitleFont { return legendTitleFont;}
- legendFont      { return legendFont;}
- ticLabelFont    { return ticLabelFont;}
- (NSPoint) legendBoxOrigin { return legendbox.origin;}
- (NSPoint) xTitleBoxOrigin { return xtitlebox.origin;}
- (NSPoint) yTitleBoxOrigin { return ytitlebox.origin;}
- (NSPoint) mainTitleBoxOrigin { return maintitlebox.origin;}

    /* All these method names start with "set" */

- setLegendBoxOrigin: (NSPoint)point
{
    legendbox.origin = point;
    return self;
}

- setXTitleBoxOrigin: (NSPoint)point
{
    xtitlebox.origin = point;
    return self;
}

- setYTitleBoxOrigin: (NSPoint)point
{
    ytitlebox.origin = point;
    return self;
}

- setMainTitleBoxOrigin: (NSPoint)point
{
    maintitlebox.origin = point;
    return self;
}

- setMainTitleFont:aFont
{
    mainTitleFont = aFont;
    [self repositionTitles];
    return self;
}

- setXTitleFont:aFont
{
    xTitleFont = aFont;
    [self repositionTitles];
    return self;
}

- setYTitleFont:aFont;
{
    yTitleFont = aFont;
    [self repositionTitles];
    return self;
}

- setLegendFont:aFont
{
    legendFont = aFont;
    [self repositionTitles];
    return self;
}

- setLegendTitleFont:aFont
{
    legendTitleFont = aFont;
    [self repositionTitles];
    return self;
}

- setTicLabelFont:aFont
{
    ticLabelFont = aFont;
    [self repositionTitles];
    return self;
}

- (NSString *)inspectorClassName
{
    return [NSString stringWithCString:"XYPlotInspector"];
}

//#error ArchiverConversion: put the contents of your 'awake' method at the end of your 'initWithCoder:' method instead
/*
 - awake
 {
     plotParam = [[XYPlot allocWithZone:[self zone]] initWithCanvas:self];

     if(!theFontManager) theFontManager = [NSFontManager new];

     [plotParam colorOn:colorState];

     [self setXLinLogState:xLinLogState];
     [self setYLinLogState:yLinLogState];
     [self setAutoPaperState:autoPaperState];

     lineThickness = 0.0;
     borderBoxThickness = 3.0;

     gridThickness = 0.0;
     axisThickness = 0.0;
     legend = NO;
     majorTicMarks = YES;
     minorTicMarks = NO;
     errorBarBaseWidth = 3.0;

     handFormatXaxis = NO;

     handFormatYaxis = NO;

     frameBox = YES;

     [self repositionTitles];

     return self;
 }
 */
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [super encodeWithCoder:aCoder];

    [aCoder encodeValuesOfObjCTypes:"iiii",&borderBox,&gridState,&autoMaxMinState,&autoPaperState];
    [aCoder encodeValuesOfObjCTypes:"iiiii",&logoFlag,&paperSwitchRow,&colorState,&xLinLogState,&yLinLogState];

    [aCoder encodeValuesOfObjCTypes:"ffff",&borderBoxThickness,&lineThickness,&ppxunit,&ppyunit];

    [aCoder encodeValuesOfObjCTypes:"fff",&xIncValue,&xMinValue,&xMaxValue];
    [aCoder encodeValuesOfObjCTypes:"fff",&yIncValue,&yMinValue,&yMaxValue];

    [aCoder encodeValuesOfObjCTypes:"*****",&xAxisTitle,&yAxisTitle,&mainTitle,&curveTitle,&legendTitle];

    [aCoder encodeValuesOfObjCTypes:"@@@",&xTitleFont,&yTitleFont,&mainTitleFont];
    [aCoder encodeValuesOfObjCTypes:"@@@",&legendFont,&legendTitleFont,&ticLabelFont];
}

- (id)initWithCoder:(NSCoder *)aDecoder
{
    [super initWithCoder:aDecoder];

    [aDecoder decodeValuesOfObjCTypes:"iiii",&borderBox,&gridState,&autoMaxMinState,&autoPaperState];
    [aDecoder decodeValuesOfObjCTypes:"iiiii",&logoFlag,&paperSwitchRow,&colorState,&xLinLogState,&yLinLogState];

    [aDecoder decodeValuesOfObjCTypes:"ffff",&borderBoxThickness,&lineThickness,&ppxunit,&ppyunit];

    [aDecoder decodeValuesOfObjCTypes:"fff",&xIncValue,&xMinValue,&xMaxValue];
    [aDecoder decodeValuesOfObjCTypes:"fff",&yIncValue,&yMinValue,&yMaxValue];

    [aDecoder decodeValuesOfObjCTypes:"*****",&xAxisTitle,&yAxisTitle,&mainTitle,&curveTitle,&legendTitle];	

    [aDecoder decodeValuesOfObjCTypes:"@@@",&xTitleFont,&yTitleFont,&mainTitleFont];
    [aDecoder decodeValuesOfObjCTypes:"@@@",&legendFont,&legendTitleFont,&ticLabelFont];

    xIncValue = 0.0;
    xMinValue = 0.0;
    xMaxValue = 0.0;
    yIncValue = 0.0;
    yMinValue = 0.0;
    yMaxValue = 0.0;

    logoFlag = NO;

    return self;
}

- setGridDotted:(int)v {gridDotted = v;return self;}

- removeXLabels
{
    handFormatXaxis = YES;
    xFormatLeft = 0; xFormatRight = 0; xFormatExponent = 0;
    return self;
}

- removeYLabels
{
    handFormatYaxis = YES;
    yFormatLeft = 0; yFormatRight = 0; yFormatExponent = 0;
    return self;
}

- redrawPlot:sender
{
    styledLines = [[switchesMatrix cellAtRow:4 column:0] intValue];
    colorState = [[switchesMatrix cellAtRow:3 column:0] intValue];
    [plotParam colorOn:colorState];
    opaqueBackground = [[switchesMatrix cellAtRow:5 column:0] intValue];
    expandMode = [[switchesMatrix cellAtRow:6 column:0] intValue];

    [self setGridDotted:[[switchesMatrix cellAtRow:0 column:0] intValue]];

    if ([[switchesMatrix cellAtRow:1 column:0] intValue] == 0) [self removeXLabels];
    else handFormatXaxis = NO;

    if ([[switchesMatrix cellAtRow:2 column:0] intValue] == 0) [self removeYLabels];
    else handFormatYaxis = NO;

    [self setXMinValue:[[XYMatrix cellAtRow:0 column:0] doubleValue]];
    [self setXIncValue:[[XYMatrix cellAtRow:1 column:0] doubleValue]];
    [self setXMaxValue:[[XYMatrix cellAtRow:2 column:0] doubleValue]];

    [self setYMinValue:[[XYMatrix cellAtRow:3 column:0] doubleValue]];
    [self setYIncValue:[[XYMatrix cellAtRow:4 column:0] doubleValue]];
    [self setYMaxValue:[[XYMatrix cellAtRow:5 column:0] doubleValue]];

    lineThickness = [[XYMatrix cellAtRow:6 column:0] floatValue];

    [self display];
    return self;
}

- resetMinMax:sender
{
    [plotParam resetMinMax:self];
    [[XYMatrix cellAtRow:0 column:0] setDoubleValue: [plotParam provideXmin]];
    [[XYMatrix cellAtRow:1 column:0] setDoubleValue: [plotParam provideXinc]];
    [[XYMatrix cellAtRow:2 column:0] setDoubleValue: [plotParam provideXmax]];

    return self;
}

- copyPStoPboard
{
    id pb;

    pb = [NSPasteboard generalPasteboard];
    [pb declareTypes:[NSArray arrayWithObject:NSPostScriptPboardType] owner:self];

    [self writeEPSInsideRect:[self bounds] toPasteboard:pb];

    return self;
}

- saveDataAsTxt
{
    NSSavePanel *panneau_sauvegarde;
    FILE *fp;
    int save,i,j;
    float offset;

    panneau_sauvegarde = [NSSavePanel savePanel];
    [panneau_sauvegarde setTitle:@"Fichier TEXTE"];
    [panneau_sauvegarde setRequiredFileType:@"dat"];

    save = [panneau_sauvegarde runModal];
    if (save == NSOKButton)
      {
        fp = (FILE *)fopen([[panneau_sauvegarde filename] cString],"wt");

        offset = [[XYMatrix cellAtRow:7 column:0] floatValue];

        for(i=0;i<initialNbPoints;i++)
          {
            if (initialTabX != NULL) fprintf(fp, "%g ", initialTabX[i]);
            else fprintf(fp, "%d ", i);

            for(j=0; j<initialNbVoies; j++)
              {
                fprintf(fp, "%g ", initialTabY[j][i] + j*offset);
              }

            fprintf(fp, "\n");
          }

        fclose(fp);
      }
    return self;
}

- executeCommand:sender
{
    int t;

    t = [[sender selectedCell] tag];

    switch(t)
      {
        case 0 : {[self redrawPlot:self];break;}
        case 1 : {[self resetMinMax:self];break;}
        case 2 : {[self copyTIFtoPasteBoard];break;}
        case 3 : {[self saveAsTiff:self];break;}
        case 4 : {[self makeStreamAndPlot];break;}
        case 5 : {[self saveDataAsTxt];break;}
      }
    return self;
}

- (void)mouseDown:(NSEvent *)e
/*
 * This code taken from the Mandelbrot example in /NextDeveloper (and modified).
 * We implement the mouseDown method so the user can sweep out a section of
 * the view and select that as the current window in which to view the curve(s).
 */
{
  int looping = YES;
  NSRect bbox;
  NSPoint startPoint, currPoint;
  float xmin, xmax, ymin, ymax;
  register float t1, t2, t3, t4;
  int niceIntInc;
  double niceFloatInc;
  int  zooming;
  BOOL xAxisIsLog = [plotParam xAxisIsLog];
  BOOL yAxisIsLog = [plotParam yAxisIsLog];

  zooming = ZOOM;

  if (zooming == ZOOM) {	/* really zooming */
      if (xAxisIsLog) {
          xmin = (float)log10([plotParam provideXmin]) * ppxunit;
          xmax = (float)log10([plotParam provideXmax]) * ppxunit;
      }
      else {
          xmin = [plotParam provideXmin] * ppxunit;
          xmax = [plotParam provideXmax] * ppxunit;
      }
      if (yAxisIsLog) {
          ymin = (float)log10([plotParam provideYmin]) * ppyunit;
          ymax = (float)log10([plotParam provideYmax]) * ppyunit;
      }
      else {
          ymin = [plotParam provideYmin] * ppyunit;
          ymax = [plotParam provideYmax] * ppyunit;
      }

      startPoint = [e locationInWindow];
      startPoint = [self convertPoint:startPoint fromView:nil];
      bbox = NSMakeRect(startPoint.x, startPoint.y, 0.0, 0.0);
      [self lockFocus];
      while (looping) {
          e=[[self window] nextEventMatchingMask:NSLeftMouseUpMask | NSLeftMouseDraggedMask];
          currPoint = [e locationInWindow];
          currPoint = [self convertPoint:currPoint fromView:nil];
          bbox.size.width = (currPoint.x - startPoint.x);
          //bbox.size.height = (currPoint.y - startPoint.y);
          bbox.size.height = [self bounds].size.height;
          bbox.origin.y   = 0.;
          /* Normalize bbox to always have positive width and height */
          if (bbox.size.width < 0) {
              bbox.size.width = -bbox.size.width;
              bbox.origin.x   = startPoint.x - bbox.size.width;
          }
          if (bbox.size.height < 0) {
              bbox.size.height = -bbox.size.height;
              bbox.origin.y    = startPoint.y - bbox.size.height;
          }

          PSnewinstance();
          if ((looping = ([e type] == NSLeftMouseDragged))) {
              PSsetinstance(YES);
              //NSFrameRect(bbox);
              NSHighlightRect(bbox);
              PSsetinstance(NO);
          }
      }
      [self unlockFocus];

      if ((bbox.size.width > 0) && (bbox.size.height > 0)) {
          /* At this point, bbox is in window coordinates.  Convert to curve
          * coordinates based on this view's coordinates and the bounding box.
          */

          xmin = xmin + (bbox.origin.x - XOFFSET);
          xmax = xmin + bbox.size.width;
          ymin = ymin + (bbox.origin.y - YOFFSET);
          ymax = ymin + bbox.size.height;

          /* save old min/max -- must adjust if log axis */
          t1 = xmin/ppxunit;
          t2 = xmax/ppxunit;
          t3 = ymin/ppyunit;
          t4 = ymax/ppyunit;
          if (xAxisIsLog) {
              t1 = (float) pow((double)10.0, (double)t1);
              t2 = (float) pow((double)10.0, (double)t2);
          }
          if (yAxisIsLog) {
              t3 = (float) pow((double)10.0, (double)t3);
              t4 = (float) pow((double)10.0, (double)t4);
          }
          [plotParam stackOldMinMax:t1 :t2 :t3 :t4];

          if (xAxisIsLog) {
              [plotParam resetXmin:pow((double)10.0, (double)(xmin/ppxunit))];
              [plotParam resetXmax:pow((double)10.0, (double)(xmax/ppxunit))];
          }
          else {
              [plotParam resetXmin:(double)(xmin/ppxunit)];
              [plotParam resetXmax:(double)(xmax/ppxunit)];
          }
          if (yAxisIsLog) {
              [plotParam resetYmin:pow((double)10.0, (double)(ymin/ppyunit))];
              [plotParam resetYmax:pow((double)10.0, (double)(ymax/ppyunit))];
          }
          else {
              [plotParam resetYmin:(double)(ymin/ppyunit)];
              [plotParam resetYmax:(double)(ymax/ppyunit)];
          }

          niceFloatInc = (double)((xmax-xmin)/ppxunit)/10.;
          niceFloatInc = niceFloatInc * 100.;
          niceIntInc = (int)niceFloatInc;
          niceFloatInc = niceIntInc/100.;

          [[XYMatrix cellAtRow:0 column:0] setDoubleValue: (double)(xmin/ppxunit)];
          [[XYMatrix cellAtRow:1 column:0] setDoubleValue: niceFloatInc];
          [[XYMatrix cellAtRow:2 column:0] setDoubleValue: (double)(xmax/ppxunit)];

          /*  Call [self display] to force current values of xmin/xmax/ymin/ymax
              *  to take effect (otherwise xmin, etc., get incremented too many times).
              */
          [self redrawPlot:self];
      }
  }
}


@end
